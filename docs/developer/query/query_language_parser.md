# Query language parser

A parser enables parsing queries, constraints, classifier and value objects from
their [string representation](/docs/research/en/assignment/querying/query_language.md).

## Usage

Parsing is done using query language parser `io.evitadb.api.query.QueryParser` which provides methods for queries,
constraints
classifiers and values parsing.

| Method                                    | Description                                                                                           |
|-------------------------------------------|-------------------------------------------------------------------------------------------------------|
| `parseQuery(String, ...)`                 | Parses whole query from string representation with inner constraints and inner literals               |
| `parseHeadConstraintList(String, ...)`    | Parses whole head constraints from string representation with inner constraints and inner literals    |
| `parseFilterConstraintList(String, ...)`  | Parses whole filter constraints from string representation with inner constraints and inner literals  |
| `parseOrderConstraintList(String, ...)`   | Parses whole order constraints from string representation with inner constraints and inner literals   |
| `parseRequireConstraintList(String, ...)` | Parses whole require constraints from string representation with inner constraints and inner literals |
| `parseClassifier(String, ...)`            | Parses classifier from string representation                                                          |
| `parseValue(String, ...)`                 | Parses value from string representation                                                               |

Each method has several variants for passing no arguments, positional arguments, named arguments or both.

In addition to that, for better security `parseQuery(...)` and `parse*Constraint` methods run in safe mode to ensure that
values can be inserted only through parameters (positional or named). Mainly for prototyping or testing, there are
unsafe variants of these methods: `parseQueryUnsafe(...)` and `parse*ConstraintUnsafe(...)`.

*Note: `parseClassifier(...)` and `parseValue(...)` both run in unsafe mode by default because without literals support
there is no need to parse classifiers or values.*

There is default implementation `io.evitadb.api.query.parser.DefaultQueryParser` which handles parsing using custom
[ANTLR4](https://github.com/antlr/antlr4) grammar.

This implementation is thread safe so only single instance is needed, and you can use `getInstance()` method that
returns this shared instance.

### Examples

Parsing query:

```java
QueryParser parser=DefaultQueryParser.getInstance();

Query myQuery1=parser.parseQuery("query(collection(?), filterBy(attributeEqualsTrue(?)))","a","b");
Query myQuery2=parser.parseQuery("query(collection(@col), filterBy(attributeEqualsTrue(@attr)))",Map.of("col","a","attr","b");

Query myQuery3=parser.parseQueryUnsafe("query(collection('a'), filterBy(attributeEqualsTrue('b')))");
```

Parsing constraint:

```java
QueryParser parser=DefaultQueryParser.getInstance();

FilterBy myFilter1=parser.parseFilterConstraint("filterBy(attributeEqualsTrue(?))","b");
FilterBy myFilter2=parser.parseFilterConstraint("filterBy(attributeEqualsTrue(@attr))",Map.of("attr","b"));

FilterBy myFilter3=parser.parseFilterConstraintUnsafe("filterBy(attributeEqualsTrue('b'))");
```

Parsing classifier:

```java
QueryParser parser=DefaultQueryParser.getInstance();

String myClassifier1=parser.parseClassifier("'hello'");
String myClassifier2=parser.parseClassifier("?","hello");
String myClassifier3=parser.parseClassifier("@clas",Map.of("clas","hello"));
```

Parsing value:

```java
QueryParser parser=DefaultQueryParser.getInstance();

Long myValue1=parser.parseValue("10");
Long myValue2=parser.parseValue("?",10L);
Long myValue3=parser.parseValue("@val",Map.of("val",10L));
```

## Developing parser

As stated above there is prepared interface `io.evitadb.api.query.QueryParser` to support parsing different parts of
query language.

### Extending default parser implementation

Default implementation (`io.evitadb.api.query.parser.DefaultQueryParser`) is thread safe and is built on the parser
and lexer generated by [ANTLR4](https://github.com/antlr/antlr4) tool for a building parse tree using custom grammar.

#### Getting started

Before extending default parser you should know basics of ANTLR4 grammar
*(check official [docs](https://github.com/antlr/antlr4/blob/master/doc/index.md))*.
Also check the [setup guide](https://github.com/antlr/antlr4/blob/master/doc/getting-started.md) for necessary tools to
be able to debug grammar and generate necessary classes from grammar. [There are](https://www.antlr.org/tools.html)
IDE tools as well.

All necessary generated classes must be inside package `io.evitadb.api.query.parser.grammar` and are expected to be
regenerated when the grammar changes.

*Note: generator also generates non-class files which are currently not needed and can be deleted after every
generation.*

#### How it works

The [grammar](#grammar) is core for parsing and is specified in single separate file that is used by the ANTLR4 to
generate a parser and lexer.

The generated ANTLR4 parser and lexer are used to build a parse tree.

To walk and parse the parse tree to actual objects the ANTLR4 generator can generate classes either for listener pattern
approach or visitor pattern approach. Our parser uses the visitor pattern approach because it has the advantage of
directly
returning parsed values but on the other hand each visitor have to walk tree by itself *(which is not problem in our
case)*.

All custom implemented visitors extends the base  `io.evitadb.api.query.parser.visitor.EvitaQLBaseVisitor`. Custom
visitors are
in the package `io.evitadb.api.query.parser.visitor` and are separated by a subject of parsing. Each visitor is then
responsible for calling other visitors to walk the parse tree.

Finally, these custom visitors are invoked in the `DefaultQueryParser` on grammar's root rules.

#### Grammar

The grammar is written in the [ANTLR4](https://github.com/antlr/antlr4) syntax in the
file `META-INF/io/evitadb/api/query/parser/EvitaQL.g4`
The file contains both parser rules and lexer rules for Evita query language and is logically structured into sections:

- **root rules**
    - specifiy parser rules for the situation when you want to parse whole string *(e.g. whole string is single query,
      single constraint)*
    - are used as entries for parsing in the parser
- **query rules**
    - specify syntax of whole query
- **constraint rules**
    - specify syntax of each constraint separated by type *(head, filterBy, orderBy, require)*
    - separation of types was chosen for better readability and ease of building constraint containers of a single type
- **argument rules**
    - specify syntax of query and constraint argument listings
    - these rules are separated for better readability of constraints and possible reusability of argument listings
    - even if you need unique argument listing, it is better to specify it as separate rule to provide better
      readability
      and a consistent label across other constraints
- **classifier rules**
    - specify syntax of classifiers
- **value rules**
    - specify syntax of all supported value types
    - rules consist of parser rules and lexer rules bellow
- **tokens**
    - specify lexer rules for concrete tokens by which the lexer tokenizes

#### Parse mode

Currently, there are 2 modes: `ParseMode.SAFE` and `ParseMode.UNSAFE`. The safe mode is default and is supposed to
reduce possible injection attacks by letting clients to pass values only through parameters, not by literals. Unsafe
mode must be enabled explicitly and allows passing of values both ways.

#### Parse context

`ParseContext` is used to pass shared metadata to all visitors during single parsing. Currently, it
contains [parse mode](#parse-mode) and client argument for resolving parameters. Unfortunately, ANTLR-generated parser
doesn't allow passing arbitrary object to tree parsing and creating the whole stack of visitor for every query parsing
would be expensive and unnecessary. Therefore context is passed in thread local variable
of [parser executor](#parser-executor) and is accessible in every visitor.

#### Parser executor

Every single parsing should be wrapped inside `ParserExecutor` with brand new [parse context](#parse-context) every time
to ensure that visitors have access to current [parse context](#parse-context).

#### Implemented visitors

- `EvitaQLQueryVisitor`
    - a visitor implementation for parsing whole query
    - constraints parsing is delegated to constraint visitor
- `EvitaQLConstraintVisitor`
    - a visitor implementation for parsing all types of constraints
    - literals parsing is delegated to literal visitor
    - this visitor delegates all parsing to visitor implementations by a constraint type:
        - `EvitaQLHeadConstraintVisitor`
            - a visitor implementation for parsing all head constraints
            - all head constraints are delegated to this visitor
        - `EvitaQLFilterConstraintVisitor`
            - a visitor implementation for parsing all filter constraints
            - all filter constraints are delegated to this visitor
        - `EvitaQLOrderConstraintVisitor`
            - a visitor implementation for parsing all order constraints
            - all order constraints are delegated to this visitor
        - `EvitaQLRequireConstraintVisitor`
            - a visitor implementation for parsing all require constraints
            - all require constraints are delegated to this visitor
- `EvitaQLClassifierTokenVisitor`
    - a visitor implementation for parsing classifiers and their variadic variants
- `EvitaQLValueTokenVisitor`
    - a visitor implementation for parsing values and their variadic variants
    - a user can specify which types are allowed

#### Parser factory

To ensure that used parser and lexer are properly configured, one should use `io.evitadb.api.query.parser.ParserFactory#getParser` 
to instantiate parser for a string to parse.

#### Error handling

There are currently only two exceptions that should come out of `QueryParser` to client: `io.evitadb.api.query.parser.error.EvitaQLInvalidQueryError` 
and `io.evitadb.api.exception.EvitaInternalError`.

If during parsing occur any error that is caused by client (syntax error, invalid arguments, ...) the `EvitaQLInvalidQueryError` 
must be thrown or underlying similar exception must be wrapped into this one. This ensure that client receives at least 
information about position of error, even if error message is not very helpful. If there is an unexpected error on the 
parser side that client cannot fix the generic `EvitaInternalError` should be thrown.

There are several places that handles this logic. At highest level there is `io.evitadb.api.query.parser.ParserExecutor` 
which catches any exception that occurred during parsing and either re-throws the `EvitaQLInvalidQueryError` or throws `EvitaInternalError` 
on any unknown exceptions. Each parser should then use the `io.evitadb.api.query.parser.error.EvitaQLBailErrorStrategy` 
which doesn't try to fix any syntax errors and instead throws a `EvitaQLInvalidQueryError` which somewhat helpful message 
about expected syntax. Any other syntax errors are caught by the `io.evitadb.api.query.parser.error.EvitaQLErrorReporter`
that should be added to both lexel and parser and also throws descriptive `EvitaQLInvalidQueryError`. 
Finally, the `io.evitadb.api.query.parser.visitor.EvitaQLBaseVisitor` comes with `parse()` method that should be used 
by every `visit*` method in concrete visitors to ensure that any invalid usage errors from underlying parser functions 
are wrapped into the `EvitaQLInvalidQueryError`.

#### Classifiers

Classifiers can be either parameters or string literals and are used for specifying e.g. entity types or attribute names
in constraint arguments. There is a convenient wrapper `Classifier` for getting either single classifier or variadic
array of classifiers without need for manual mappings.

#### Values

Value represents concrete value of some supported type parsed from string representation. Values are mostly used
as generic arguments inside constraints. Values can be either parameters or literals.

There is a wrapper `Value` which serves as an output of a parsed parameters or literals containing concrete value with a
type
corresponding to string representation syntax. Main use is to provide a united way of outputting a parsed value from
the value visitor.
The `Value` wrapper also provides convenient getters for returning parsed value in a desired type.

For parsing values there is `EvitaQLValueTokenVisitor` which supports all literal types and parameters and as result
returns the `Value`
wrapper. It also supports specifying list of allowed data types so when a value which is being parsed does not have
allowed type
the `EvitaQLLiteralParsingFailedException` is thrown.

```java
ctx.args.attributeValue
	.accept(comparableValueTokenVisitor) // or EvitaQLValueTokenVisitor.withAllowedTypes(...)
	.getValue()
```

On top of the data type validation, this visitor checks current [parse mode](#parse-mode) and decides if literals are
allowed, otherwise only parameters are allowed.

The parser does not currently support all data types supported by the Evita itself *(as shown above)*.
To be more specific the parser does not support only more specific data types variations such as `byte` or `char`.
All core data types are of course supported:

- **string literal** - converts to `java.lang.String`
- **int literal** - converts to `java.lang.Long`
- **float literal** - converts to `java.math.BigDecimal`
- **boolean literal** - converts to `java.lang.Boolean`
- **date literal** - converts to `java.time.LocalDate`
- **time literal** - converts to `java.time.LocalTime`
- **date time literal** - converts to `java.time.LocalDateTime`
- **offset date time literal** - converts to `java.time.OffsetDateTime`
- **locale literal** - converts to `java.lang.Locale`
- **number range literal** - converts to `io.evitadb.api.dataType.NumberRange`
- **date range literal** - converts to `io.evitadb.api.dataType.DateTimeRange`
- **multiple literal** - converts to `io.evitadb.api.dataType.Multiple`

For more info check [supported data types](/docs/research/en/assignment/model/data_types.md).

#### Variadic classifiers and values

There is support for passing arrays/iterables of values through parameters resulting in Java varargs. Constraint with
variadic arguments can be then used in following ways:

```
// attributeInSet(attributeName, attributeValues...)
attributeInSet('code', 1) // normal array of one attributeValue
attributeInSet('code', 1, 2, 3) // array of multile attributeValues
attributeInSet('code', ?) // if passed an array or iterable, it is transformed to attributeValues, if passed single value it is treated as single value and wrapped inside target array
attributeInSet('code', ?, ?, ?) // each parameter is treated as single value which are then wrapped into target array
attributeInSet('code', @values) // if passed an array or iterable, it is transformed to attributeValues, if passed single value it is treated as single value and wrapped inside target array
attributeInSet('code', @v1, @v2, @v3) // each parameter is treated as single value which are then wrapped into target array
```

This logic is handled separately for classifiers and values in their visitors as other type of values.

#### Extending constrains

For adding a new or modifying an existing constraint you firstly need to modify the grammar to acknowledge the change.
After new classes are generated you need to override a corresponding visiting(parsing) method in the
`EvitaQLHeadConstraintVisitor`, `EvitaQLFilterConstraintVisitor`, `EvitaQLOrderConstraintVisitor`,
or `EvitaQLRequireConstraintVisitor`
with parsing logic and return a desired constraint object from the `ctx.getText()`. If the argument listing convention
is followed individual arguments can be accessed via the `ctx.args.{label/rule}`. 

*Note:* that you have to think about 
order of constraint arguments parsing due to the positional parameters which are sensitive to correct order.

For parsing individual arguments you should use either the existing `EvitaQLClassifierTokenVisitor` *(check
the [classifiers](#classifiers) section)*
or the existing `EvitaQLValueTokenVisitor` which supports all data types supported by query language *(check
the [values](#values) section)*.

Example of a filter constraint which works as a container for an inner filter constraints:

```
// grammar

filterConstraint
    : ...
    | 'and' args = filterConstraintContainerArgs # andConstraint
    ...
    
filterConstraintContainerArgs 
    : ARGS_OPENING constraints += filterConstraint (ARGS_DELIMITER constraints += filterConstraint)* ARGS_CLOSING 
    ;
```

```java
// parsing
@Override
public Constraint<?> visitAndConstraint(EvitaQLParser.AndConstraintContext ctx){
	return parse(
        ctx,
        () -> new And(
            ctx.args.constraints
            .stream()
            .map(fc->(FilterConstraint)fc.accept(this))
            .toArray(FilterConstraint[]::new)
        )
    );
}
```

Example of a leaf constraint:

```
// grammar

filterConstraint
    : ...
    | 'attributeEquals' args = nameWithValueArgs # equalsConstraint
    ...
    
nameWithValueArgs 
    : ARGS_OPENING atributeName = classifierToken ARGS_DELIMITER attributeValue = valueToken ARGS_CLOSING 
    ;
```

```java
// parsing
@Override
public Constraint<?> visitAttributeEqualsConstraint(EvitaQLParser.AttributeEqualsConstraintContext ctx){
	return parse(
    	ctx,
        () -> new AttributeEquals(
            ctx.args.atributeName.accept(classifierTokenVisitor).asSingleClassifier(),
            ctx.args.attributeValue.accept(comparableTypesValueTokenVisitor).asSerializableAndComparable()
        )
    );
}
```

#### Extending literals

For adding a new or modifying an existing literals, you firstly need to modify the grammar to acknowledge the change.
Then you need to generate new classes from the grammar.

Then override a corresponding visit (parse) method in the `EvitaQLValueTokenVisitor` (potentially even
in `EvitaQLClassifierTokenVisitor`) with parsing logic and return a desired value encapsulated in the `Value` (or
potentially in `Classifier`) wrapper.

To allow users to disallow this type from being parsed call the `assertIfDataTypeIsAllowed(ctx, class)` with a type
being parsed
and a current parsing context before the actual parsing. Exception is thrown when the type is not allowed.

If the specific literal should be forbidden in safe mode (as it should) call `assertLiteralIsAllowed()`

Examples of literals:

```
// grammar

valueToken
    : STRING # stringValueToken
    ...
    
STRING : '\'' .*? '\'' ;
```

```java
// parsing
@Override
public Value visitStringValueToken(EvitaQLParser.StringValueTokenContext ctx){
    return parse(
    	ctx,
        String.class,
        () -> ctx.getText().substring(1,ctx.getText().length()-1)
    )
}
```

```
// grammar

valueToken
    : ...
    | DATE # dateValueToken
    ...
    
DATE : [0-9][0-9][0-9][0-9] '-' [0-9][0-9] '-' [0-9][0-9] ;
```

```java
// parsing
@Override
public Value visitDateValueToken(EvitaQLParser.DateValueTokenContext ctx){
    assertIsLiteralAllowed(ctx);
	assertIfDataTypeIsAllowed(ctx,LocalDate.class);
	return new Value(
	    LocalDate.from(DateTimeFormatter.ISO_LOCAL_DATE.parse(ctx.getText()))
	);
}
```
