<!--
  ~
  ~                         _ _        ____  ____
  ~               _____   _(_) |_ __ _|  _ \| __ )
  ~              / _ \ \ / / | __/ _` | | | |  _ \
  ~             |  __/\ V /| | || (_| | |_| | |_) |
  ~              \___| \_/ |_|\__\__,_|____/|____/
  ~
  ~   Copyright (c) 2024
  ~
  ~   Licensed under the Business Source License, Version 1.1 (the "License");
  ~   you may not use this file except in compliance with the License.
  ~   You may obtain a copy of the License at
  ~
  ~   https://github.com/FgForrest/evitaDB/blob/main/LICENSE
  ~
  ~   Unless required by applicable law or agreed to in writing, software
  ~   distributed under the License is distributed on an "AS IS" BASIS,
  ~   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~   See the License for the specific language governing permissions and
  ~   limitations under the License.
  -->

<!DOCTYPE html>
<html lang="cs">
<head>
	<meta charset="UTF-8">
	<title>evitaDB â€“ spuÅ¡tÄ›nÃ­, definice schÃ©matu a naplnÄ›nÃ­ daty</title>
</head>
<body>
<header>
	<h1>evitaDB â€“ spuÅ¡tÄ›nÃ­, definice schÃ©matu a naplnÄ›nÃ­ daty</h1>
	<time datetime="2024-01-14">14. ledna 2024</time>
	<p>
		V tomto dÃ­lu si pÅ™edstavÃ­me, jak jsou data v evitaDB organizovÃ¡na, vysvÄ›tlÃ­me si zÃ¡kladnÃ­ pojmy jako jsou
		katalog, typ entity a schÃ©ma. VyzkouÅ¡Ã­me si zaloÅ¾it novÃ½ katalog a souvisejÃ­cÃ­ schÃ©mata v databÃ¡zi a naplnit
		ji zÃ¡kladnÃ­mi daty.
	</p>
</header>
<article>

	<p>
		PojÄme si na Ãºvod ukÃ¡zat, jakÃ© moÅ¾nosti provozovÃ¡nÃ­ evitaDB nabÃ­zÃ­. DatabÃ¡ze je
		bÄ›Å¾nÃ¡ Java aplikace (JAR), kterou je moÅ¾nÃ© zabalit a provozovat v rÃ¡mci jinÃ©
		Java aplikace (tzv. embedded reÅ¾im) nebo je moÅ¾nÃ© ji spustit jako samostatnÃ½
		proces, kterÃ½ lze nÃ¡slednÄ› pouÅ¾Ã­vat z libovolnÃ© jinÃ© aplikace (a jazykovÃ©
		platformy). Pro zjednoduÅ¡enÃ­ instalace je pÅ™ipravenÃ½ Docker image, kterÃ½
		obsahuje jak databÃ¡zovÃ½ program, tak i sprÃ¡vnou verzi virtuÃ¡lnÃ­ho stroje Java a
		podkladovÃ½ operaÄnÃ­ systÃ©m. V tomto ÄlÃ¡nku budeme pouÅ¾Ã­vat pouze variantu
		spuÅ¡tÄ›nÃ­ evitaDB jako Docker kontejneru â€“â  ostatnÃ­ zpÅ¯soby jsou popsÃ¡ny v <a
			href="https://evitadb.io/documentation/get-started/run-evitadb?codelang=evitaql">dokumentaci</a>.
	</p>
	<h2>ZprovoznÄ›nÃ­ Docker kontejneru</h2>
	<p>
		Ke spuÅ¡tÄ›nÃ­ databÃ¡ze tedy budete potÅ™ebovat mÃ­t na svÃ©m lokÃ¡lnÃ­m vÃ½vojovÃ©m
		prostÅ™edÃ­ nainstalovanÃ½ <a
			href="https://docs.docker.com/engine/install/">Docker</a>. NÃ¡slednÄ› staÄÃ­
		spustit tento pÅ™Ã­kaz:
	</p>

	<pre>docker run --name evitadb -i --rm --net=host \
       -e "api.exposedOn=localhost" \
       index.docker.io/evitadb/evitadb:latest
	</pre>

	<p>
		TÃ­m si stÃ¡hnete aktuÃ¡lnÃ­ verzi databÃ¡ze, vytvoÅ™Ã­te si lokÃ¡lnÄ› kontejner s nÃ¡zvem
		â€evitadbâ€œ a nasdÃ­lÃ­te mu lokÃ¡lnÃ­ sÃ­Å¥ vaÅ¡eho poÄÃ­taÄe. Kontejner se spustÃ­ v
		interaktivnÃ­m reÅ¾imu, takÅ¾e uvidÃ­te vÃ½stup jeho konzole a bude jej moci zastavit
		pomocÃ­ kombinace klÃ¡ves Ctrl+C. Pokud databÃ¡zi pouÅ¡tÃ­te na jinÃ©m operaÄnÃ­m
		systÃ©mu jak Linux, budete potÅ™ebovat ponÄ›kud sloÅ¾itÄ›jÅ¡Ã­ variantu spuÅ¡tÄ›nÃ­ s
		manuÃ¡lnÃ­m mapovÃ¡nÃ­m portÅ¯ (alespoÅˆ do tÃ© doby neÅ¾ Docker vyÅ™eÅ¡Ã­ <a
			href="https://github.com/docker/roadmap/issues/238">issue #238</a>):
	</p>

	<pre>docker run --name evitadb -i --rm -p 5555:5555 -p 5556:5556 -p 5557:5557 \
       -e "api.exposedOn=localhost" \
       index.docker.io/evitadb/evitadb:latest
	</pre>

	<p>
		Po nastartovÃ¡nÃ­ uvidÃ­te vÃ½stup na konzoli podobnÃ½ tomuto:
	</p>

	<pre>            _ _        ____  ____
  _____   _(_) |_ __ _|  _ \| __ )
 / _ \ \ / / | __/ _` | | | |  _ \
|  __/\ V /| | || (_| | |_| | |_) |
 \___| \_/ |_|\__\__,_|____/|____/

beta build 2024.6.1 (keep calm and report bugs ğŸ˜‰)
Visit us at: https://evitadb.io

Log config used: META-INF/logback.xml (original file `/evita/logback.xml` doesn't exist)
Server name: evitaDB-b493e0c4c8d06865
17:37:54.253 INFO  i.e.e.g.GraphQLManager - Built GraphQL API in 0.000000151s
17:37:54.305 INFO  i.e.e.r.RestManager - Built REST API in 0.000000048s
17:37:54.924 INFO  i.e.e.l.LabManager - Built Lab in 0.000000062s
Root CA Certificate fingerprint:        C2:62:C6:B7:97:B1:B6:82:08:D0:C6:5F:2F:0B:A1:EA:F7:A2:01:08:C3:7C:20:60:CC:02:7C:1E:5F:F1:57:B3
API `graphQL` listening on              https://localhost:5555/gql/, https://d651d19eee1a:5555/gql/
API `rest` listening on                 https://localhost:5555/rest/, https://d651d19eee1a:5555/rest/
API `gRPC` listening on                 https://localhost:5556/, https://d651d19eee1a:5556/
API `system` listening on               http://localhost:5557/system/, http://d651d19eee1a:5557/system/
   - server name served at:             http://localhost:5557/system/server-name, http://d651d19eee1a:5557/system/server-name
   - CA certificate served at:          http://localhost:5557/system/evitaDB-CA-selfSigned.crt, http://d651d19eee1a:5557/system/evitaDB-CA-selfSigned.crt
   - server certificate served at:      http://localhost:5557/system/server.crt, http://d651d19eee1a:5557/system/server.crt
   - client certificate served at:      http://localhost:5557/system/client.crt, http://d651d19eee1a:5557/system/client.crt
   - client private key served at:      http://localhost:5557/system/client.key, http://d651d19eee1a:5557/system/client.key

************************* WARNING!!! *************************
You use mTLS with automatically generated client certificate.
This is not safe for production environments!
Supply the certificate for production manually and set `useGeneratedCertificate` to false.
************************* WARNING!!! *************************

API `lab` listening on                  https://localhost:5555/lab/, https://d651d19eee1a:5555/lab/
</pre>

	<p>
		Z vÃ½pisu je patrnÃ©, Å¾e evitaDB nastartovala nÄ›kolik sÃ­Å¥ovÃ½ch rozhranÃ­, kterÃ©
		mÃ¡te nynÃ­ na svÃ©m poÄÃ­taÄi dostupnÃ©:
	</p>

	<ul>
		<li>rozhranÃ­ s GraphQL protokolem,
		<li>rozhranÃ­ s REST protokolem,
		<li>rozhranÃ­ s gRPC protokolem,
		<li>systÃ©movÃ© rozhranÃ­, jehoÅ¾ ÃºÄel v tomto seriÃ¡lu rozebÃ­rat nebudeme,
		<li>a uÅ¾ivatelskÃ© rozhranÃ­ pro pÅ™Ã­stup k datÅ¯m (laboratoÅ™)
		</li>
	</ul>

	<p>
		Jak je vidno, rozhranÃ­ nastartovala jsou dostupnÃ¡ vÅ¾dy na dvou adresÃ¡ch â€“ jednÃ©
		s nÃ¡hodnÄ› generovanÃ½m nÃ¡zvem hostname, kterÃ¡ je dostupnÃ¡ pouze zevnitÅ™ Docker
		kontejneru a druhÃ¡ s nÃ¡zvem â€œlocalhostâ€, kterÃ¡ bude fungovat z vaÅ¡eho lokÃ¡lnÃ­ho
		prostÅ™edÃ­. Jejich funkÄnost si mÅ¯Å¾ete ovÄ›Å™it jednoduchÃ½m zpÅ¯sobem:
	</p>

	<p>
		<strong>GraphQL:</strong>
	</p>

	<pre>curl -k -X POST "https://localhost:5555/gql/system" \
  -H 'Content-Type: application/json' \
  -d '{"query":"{alive}"}'
	</pre>

	<p>
		<strong>REST:</strong>
	</p>

	<pre>curl -k "https://localhost:5555/rest/system/liveness" \
  -H 'Content-Type: application/json'
	</pre>

	<p>
		PÅ™Ã­padnÄ› mÅ¯Å¾ete samozÅ™ejmÄ› rozkliknout odkaz `lab` rozhranÃ­ a po odkliknutÃ­
		varovÃ¡nÃ­ o nedÅ¯vÄ›ryhodnÃ©m (self-signed) certifikÃ¡tu a nechat si zobrazit ÃºvodnÃ­
		obrazovku naÅ¡Ã­ laboratoÅ™e.
	</p>

	<h2>PrÃ¡ce s databÃ¡zÃ­ z Java klienta</h2>

	<p>
		V naÅ¡em seriÃ¡lu budeme popisovat pÅ™edevÅ¡Ã­m prÃ¡ci s databÃ¡zÃ­ z Java prostÅ™edÃ­. To
		vÅ¡ak neznamenÃ¡, Å¾e to je cesta jedinÃ¡ moÅ¾nÃ¡. KromÄ› Java klienta je k dispozici i
		klientskÃ¡ knihovna pro C# a na ostatnÃ­ch platformÃ¡ch je moÅ¾nÃ© zaÄÃ­t s
		vygenerovanÃ½m kÃ³dem na zÃ¡kladÄ› publikovanÃ½ch webovÃ½ch schÃ©mat (GraphQL, Open
		API, gRPC schÃ©ma). PlnohodnotnÃ¡ klientskÃ¡ knihovna vÅ¡ak pÅ™inÃ¡Å¡Ã­ lepÅ¡Ã­ komfort
		pÅ™edevÅ¡Ã­m pÅ™i vytvÃ¡Å™enÃ­ databÃ¡zovÃ½ch schÃ©mat a aktualizaci dat v databÃ¡zi.
		VÅ¡echny souÄasnÃ© klientskÃ© knihovny stavÃ­ na protokolu gRPC a vÄ›Å™Ã­me, Å¾e Äasem
		vzniknou porty pro dalÅ¡Ã­ programovacÃ­ jazyky (napÅ™. PHP Äi Node.js).
	</p>

	<p>
		Pro napojenÃ­ na evitaDB z Java aplikace, je potÅ™eba si nejdÅ™Ã­ve nalinkovat
		klientskou knihovnu. V buildovacÃ­m prostÅ™edÃ­ Maven staÄÃ­ pÅ™idat tuto zÃ¡vislost:
	</p>

	<pre>&lt;dependency&gt;
    &lt;groupId>io.evitadb&lt;/groupId&gt;
    &lt;artifactId>evita_db&lt;/artifactId&gt;
    &lt;version>10.1.1&lt;/version&gt;
    &lt;type>pom&lt;/type&gt;
&lt;/dependency&gt;
	</pre>

	<p>
		V Java aplikaci pak staÄÃ­ uÅ¾ jen inicializovat klienta:
	</p>

	<pre>
EvitaContract evita = new EvitaClient(
   EvitaClientConfiguration.builder()
                           .host("localhost")
                           .port(5556)
                           .build()
);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.01-connect-evitadb">https://github.com/FgForrest/evitaDB-tutorial/tree/01.01-connect-evitadb</a>
		</em>
	</p>

	<p>
		PÅ™i prÃ¡ci s evitaDB je vhodnÃ© pouÅ¾Ã­vat obecnÃ¡ rozhranÃ­, kterÃ© majÃ­ pÅ™Ã­ponu
		`Contract` â€“ v tomto pÅ™Ã­padÄ› tedy `EvitaContract`. UmoÅ¾nÃ­ vÃ¡m to jednoduÅ¡e
		pÅ™epÃ­nat mezi provozem databÃ¡ze embedovanÄ› (tj. souÄÃ¡stÃ­ vaÅ¡Ã­ aplikace) a
		vzdÃ¡lenÄ›. To ocenÃ­te pÅ™edevÅ¡Ã­m pÅ™i psanÃ­ automatizovanÃ½ch integraÄnÃ­ch testÅ¯.
	</p>

	<h3>Katalog a jeho zaloÅ¾enÃ­</h3>

	<p>
		ProtoÅ¾e se evitaDB specializuje na katalogovÃ¡ Å™eÅ¡enÃ­, je zÃ¡kladnÃ­m stavebnÃ­m
		blokem tzv. katalog. Smyslem katalogu je zapouzdÅ™it vÅ¡echna data spojenÃ¡ s
		jednou â€aplikacÃ­â€œ Äi â€<a
			href="https://en.wikipedia.org/wiki/Multitenancy">tenantem</a>â€œ a izolovat je od
		ostatnÃ­ch katalogÅ¯.
	</p>

	<p>
		NovÃ½ katalog zaloÅ¾Ã­me nÃ¡sledujÃ­cÃ­m pÅ™Ã­kazem:
	</p>

	<pre>
evita.defineCatalog("evita-tutorial");
	</pre>

	<p>
		Pokud chceme katalogu rovnou nastavit nÄ›jakÃ½ popis, tedy aktualizovat jeho
		schÃ©ma, bude nÃ¡Å¡ kÃ³d o nÄ›co delÅ¡Ã­:
	</p>

	<pre>
evita.defineCatalog("evita-tutorial")
     .withDescription("This is a tutorial catalog.")
     .updateViaNewSession(evita);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.02-setup-new-catalog">https://github.com/FgForrest/evitaDB-tutorial/tree/01.02-setup-new-catalog</a>
		</em>
	</p>

	<h3>Kolekce entit a jejich schÃ©ma</h3>

	<p>
		Katalog obsahuje jeden nebo vÃ­ce typÅ¯ entit organizovanÃ½ch v kolekcÃ­ch. Typ
		entity odpovÃ­dÃ¡ v pojetÃ­ relaÄnÃ­ databÃ¡ze sadÄ› tabulek, kterÃ© majÃ­ logickou
		souvislost. V dokumentovÃ½ch databÃ¡zÃ­ch je analogiÃ­ kolekce (napÅ™. MongoDB) nebo
		index (napÅ™. Elasticsearch).
	</p>

	<p>
		KaÅ¾dÃ¡ entita je unikÃ¡tnÄ› identifikovanÃ¡ svÃ½m primÃ¡rnÃ­m klÃ­Äem, kterÃ½ mÅ¯Å¾e
		pÅ™idÄ›lovat buÄ sama databÃ¡ze, nebo mÅ¯Å¾e bÃ½t dodanÃ½ pÅ™i vklÃ¡dÃ¡nÃ­ dat aplikacÃ­.
		PrimÃ¡rnÃ­m klÃ­Äem je datovÃ½ typ 32-bitovÃ½ integer, ale aplikace mÅ¯Å¾e pro svÃ©
		byznysovÃ© klÃ­Äe pouÅ¾Ã­vat typ UUID a ten pouÅ¾Ã­vat jako hlavnÃ­ identifikÃ¡tor
		entity. DÅ¯vody pro pouÅ¾itÃ­ datovÃ©ho typu pro primÃ¡rnÃ­ klÃ­Ä jsou podrobnÄ›ji
		popsÃ¡ny v <a
			href="https://evitadb.io/documentation/use/data-model?codelang=graphql#primary-key">dokumentaci</a>.
	</p>

	<p>
		Entita mÅ¯Å¾e dÃ¡le obsahovat tyto zÃ¡kladnÃ­ bloky dat:
	</p>

	<ul>
		<li><strong>Atributy:</strong> sada kombinacÃ­ klÃ­Ä/Ãºdaj, kde klÃ­Äem je nÃ¡zev
			atributu (`String`) a Ãºdajem je jedna nebo vÃ­ce (pole) hodnot <a
					href="https://evitadb.io/documentation/use/data-types?codelang=evitaql">povolenÃ½ch
				datovÃ½ch typÅ¯</a>; atributy se uklÃ¡dajÃ­ a naÄÃ­tajÃ­ v rÃ¡mci jednoho spoleÄnÃ©ho
			datovÃ©ho bloku a mÄ›ly by bÃ½t vyuÅ¾Ã­vÃ¡ny k uklÃ¡dÃ¡nÃ­ dat, ke kterÃ½m se v
			souvislosti s entitou velmi Äasto pÅ™istupuje nebo kterÃ© slouÅ¾Ã­ k filtrovÃ¡nÃ­ Äi
			tÅ™Ã­dÄ›nÃ­
		<li><strong>AsociovanÃ¡ data:</strong> sada kombinacÃ­ klÃ­Ä/Ãºdaj, kde klÃ­Äem je
			Å™etÄ›zec nÃ¡zvu (`String`) a Ãºdajem je jedna nebo vÃ­ce (pole) hodnot <a
					href="https://evitadb.io/documentation/use/data-types?codelang=evitaql">povolenÃ½ch
				datovÃ½ch typÅ¯</a>, Äi komplexnÃ­ objektovÃ¡ struktura (analogie k JSON typu);
			asociovanÃ¡ data by mÄ›la bÃ½t vyuÅ¾Ã­vÃ¡na pro vÅ¡echna data, kterÃ¡ se vyuÅ¾Ã­vajÃ­ jen
			zÅ™Ã­dka a jsou uklÃ¡dÃ¡na kaÅ¾dÃ¡ v samostatnÃ©m datovÃ©m bloku (naÄÃ­tajÃ­ se
			jednotlivÄ›).
		<li><strong>Ceny:</strong> pevnÄ› danÃ¡ struktura cen obsahujÃ­cÃ­ pÅ™edevÅ¡Ã­m:
			<ul>
				<li>cenu bez a s danÃ­, procento danÄ›,
				<li>nÃ¡zev cenÃ­ku (`String`),
				<li>vlastnÃ­ identifikÃ¡tor pro ÃºÄely synchronizace s externÃ­mi systÃ©my,
				<li>Äasovou platnost,
				<li>pÅ™Ã­znak, zda se jednÃ¡ o prodejnÃ­ cenu (indexovanou pro vyhledÃ¡vÃ¡nÃ­)
				</li>
			</ul>
		<li><strong>Hierarchie:</strong> primÃ¡rnÃ­ klÃ­Ä nadÅ™Ã­zenÃ© entity ve stromovÃ©
			struktuÅ™e stejnÃ©ho typu entity. Entity potom tvoÅ™Ã­ acyklickÃ½ orientovanÃ½ graf s
			â€virtuÃ¡lnÃ­m koÅ™enemâ€œ, ke kterÃ©mu se vztahujÃ­ entity, kterÃ© nemajÃ­ definovanÃ½
			svÅ¯j nadÅ™Ã­zenÃ½ uzel.
		<li><strong>Reference:</strong> sada ukazatelÅ¯ na jinÃ© entity stejnÃ©ho nebo
			jinÃ©ho typu; ukazatel mÅ¯Å¾e smÄ›Å™ovat i na entitu, kterÃ¡ nenÃ­ souÄÃ¡stÃ­ katalogu
			evitaDB (mÅ¯Å¾e se jednat o entitu v externÃ­m systÃ©mu, kterou nenÃ­ vhodnÃ©
			duplikovat do evitaDB, ale chceme ji zapojit do vÃ½poÄtÅ¯, kterÃ© evitaDB s
			referencemi umoÅ¾Åˆuje) â€“ o moÅ¾nÃ½ch vÃ½poÄtech se dozvÃ­te v dalÅ¡Ã­ch kapitolÃ¡ch
			tohoto seriÃ¡lu.
			<ul>
				<li><strong>Skupina:</strong> volitelnÃ½ ukazatel na jinou entitu, kterÃ½ umoÅ¾Åˆuje
					seskupovat reference do logickÃ½ch blokÅ¯, pro kterÃ½ platÃ­ stejnÃ¡ pravidla jako
					pro referenci samotnou (vÃ½sledky vÃ½poÄtÅ¯ nad referencemi budou vÅ¾dy respektovat
					rozloÅ¾enÃ­ dle tÃ©to skupiny).
				<li><strong>Atributy referencÃ­:</strong> sada kombinacÃ­ klÃ­Ä/Ãºdaj, kde klÃ­Äem je
					nÃ¡zev atributu (`String`) a Ãºdajem je jedna nebo vÃ­ce (pole) hodnot <a
							href="https://evitadb.io/documentation/use/data-types?codelang=evitaql">povolenÃ½ch
						datovÃ½ch typÅ¯</a>; atributy se uklÃ¡dajÃ­ a naÄÃ­tajÃ­ v rÃ¡mci spoleÄnÃ©ho datovÃ©ho
					bloku s referencemi a cÃ­lÃ­ na informace, kterÃ© dÃ¡vajÃ­ smysl pouze v souvislosti
					s touto referencÃ­ (obdoba sloupcÅ¯ na vazebnÃ­ tabulce v relaÄnÃ­ databÃ¡zi).
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Popis struktury entity je zjednoduÅ¡enÃ½. Å˜adu dalÅ¡Ã­ch detailÅ¯ a dÅ¯vodÅ¯ pro
		existenci tÄ›chto zÃ¡kladnÃ­ch blokÅ¯ se doÄtete v <a
			href="https://evitadb.io/documentation/use/data-model?codelang=evitaql">dokumentaci</a>.
	</p>
	<p>
		Entitu popisuje jejÃ­ schÃ©ma. SchÃ©ma je databÃ¡zi vÅ¾dy striktnÄ› kontrolovÃ¡no, ale
		mÅ¯Å¾e vznikat dynamicky na zÃ¡kladÄ› prvnÃ­ch dat v danÃ© kolekci. PojÄme si tedy
		velmi rychle naprototypovat nÄ›jakÃ½ zÃ¡kladnÃ­ model pro jednoduchÃ½ e-commerce
		katalog:
	</p>

	<pre>// vytvoÅ™Ã­me novÃ© schÃ©ma tÃ­m, Å¾e rovnou zadÃ¡me ukÃ¡zkovÃ¡ data
evita.updateCatalog(
        "evita-tutorial",
        session -> {
            // nejdÅ™Ã­v vytvoÅ™Ã­me znaÄku Lenovo
            session.createNewEntity("Brand", 1)
                    .setAttribute("name", Locale.ENGLISH, "Lenovo")
                    .upsertVia(session);

            // pak nÄ›kolik kategoriÃ­ navzÃ¡jem spojenÃ½ch do stromu
            session.createNewEntity("Category", 10)
                    .setAttribute("name", Locale.ENGLISH, "Electronics")
                    .upsertVia(session);

            session.createNewEntity("Category", 11)
                    .setAttribute("name", Locale.ENGLISH, "Laptops")
                    // laptopy budou podÅ™Ã­zenou kategoriÃ­ elektroniky
                    .setParent(10)
                    .upsertVia(session);

            // a nakonec vytvoÅ™Ã­me produkt
            session.createNewEntity("Product")
                    // s nÄ›kolika atributy
                    .setAttribute("name", Locale.ENGLISH, "ThinkPad P15 Gen 1")
                    .setAttribute("cores", 8)
                    .setAttribute("graphics", "NVIDIA Quadro RTX 4000 with Max-Q Design")
                    // a prodejnÃ­ cenou
                    .setPrice(
                            1, "basic",
                            Currency.getInstance("USD"),
                            new BigDecimal("1420"), new BigDecimal("20"), new BigDecimal("1704"),
                            true
                    )
                    // spojÃ­me jej s vÃ½robcem
                    .setReference(
                            "brand", "Brand",
                            Cardinality.EXACTLY_ONE,
                            1
                    )
                    // a zaÅ™adÃ­me do kategorie
                    .setReference(
                            "categories", "Category",
                            Cardinality.ZERO_OR_MORE,
                            11
                    )
                    .upsertVia(session);
        }
);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.03-define-schema-on-the-fly">https://github.com/FgForrest/evitaDB-tutorial/tree/01.03-define-schema-on-the-fly</a></em>
	</p>

	<p>
		VytvÃ¡Å™enÃ­ novÃ½ch entit pouÅ¾Ã­vÃ¡ tzv. â€<a
			href="https://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a>â€œ, kterÃ½
		shromaÅ¾Äuje vÅ¡echny zmÄ›ny na danÃ© entitÄ› a v zÃ¡vÄ›reÄnÃ©m volÃ¡nÃ­ metody
		`upsertVia(session)` vytvoÅ™Ã­ seznam potÅ™ebnÃ½ch mutacÃ­, kterÃ© prostÅ™ednictvÃ­m
		pÅ™edanÃ©ho sezenÃ­ poÅ¡le na server, kde se zaloÅ¾Ã­ odpovÃ­dajÃ­cÃ­ datovÃ© struktury
		(pro lepÅ¡Ã­ pÅ™edstavu o tom, co se dÄ›je pod kapotou vyzkouÅ¡ejte mÃ­sto tÃ©to
		metody: `toInstance()` Äi `toMutations()`).
	</p>

	<p>
		Pokud chcete mÃ­t rychle vizuÃ¡lnÃ­ zpÄ›tnou vazbu, co jste v databÃ¡zi prÃ¡vÄ›
		provedli, pouÅ¾ijte nÃ¡stroj <a href="https://demo.evitadb.io">evitaLab</a>, kterÃ½
		vÃ¡m nastartuje spoleÄnÄ› s databÃ¡zÃ­ (pokud jej nezakÃ¡Å¾ete v konfiguraci). Odkaz
		na verzi, kterÃ¡ bÄ›Å¾Ã­ spoleÄnÄ› s vaÅ¡Ã­ databÃ¡zÃ­, se zobrazÃ­ po startu Docker
		kontejneru v konzoli a automaticky vÃ¡m umoÅ¾nÃ­ pÅ™Ã­stup k lokÃ¡lnÃ­m datÅ¯m v
		databÃ¡zi.
	</p>

	<p>
		StejnÄ› tak mÅ¯Å¾ete nad vaÅ¡Ã­m modelem okamÅ¾itÄ› vyzkouÅ¡et vÅ¡echna podporovanÃ¡ API:
		<a href="https://evitadb.io/documentation/use/connectors/grpc">gRPC</a>, <a
			href="https://evitadb.io/documentation/use/connectors/graphql">GraphQL</a> nebo
		<a href="https://evitadb.io/documentation/use/connectors/rest">REST</a>. Nebo si
		podle vypublikovanÃ½ch schÃ©mat (pro REST jsme zvolili cestu Open API) vygenerovat
		kostru (stub) klientskÃ©ho kÃ³du, kterÃ½ bude s daty pracovat. O tÄ›chto webovÃ½ch
		API si ale povÃ­me v nÄ›kterÃ©m z dalÅ¡Ã­ch dÃ­lÅ¯ seriÃ¡lu.
	</p>

	<h4><em>Nechce se vÃ¡m pÅ™episovat kÃ³d z ÄlÃ¡nku do svÃ©ho IDE?</em></h4>
	<p>
		<em>VÅ¡echny pÅ™Ã­klady, kterÃ© budeme popisovat v tÃ©to sÃ©rii ÄlÃ¡nkÅ¯ najdete v <a
				href="https://github.com/FgForrest/evitaDB-tutorial">ukÃ¡zkovÃ©m GitHub
			repository</a>, kde jsou zdrojovÃ© kÃ³dy pro jednotlivÃ© ÄlÃ¡nky v sÃ©rii dostupnÃ© v
			samostatnÃ½ch vÄ›tvÃ­ch. StaÄÃ­, kdyÅ¾ si provedete `checkout` odpovÃ­dajÃ­cÃ­ vÄ›tve a
			najdete si tu sprÃ¡vnou metodu v testovacÃ­ sadÄ›. NÃ¡slednÄ› uÅ¾ mÅ¯Å¾ete
			experimentovat dle svÃ© libosti.</em>
	</p>

	<p>
		AÄkoliv je tento pÅ™Ã­stup lÃ¡kavÃ½ pro rychlÃ© prototypovÃ¡nÃ­, pro seriÃ³znÃ­ vÃ½voj se
		pÅ™Ã­liÅ¡ nehodÃ­. evitaDB striktnÄ› vyÅ¾aduje, aby vÅ¡echna data, podle kterÃ½ch je
		moÅ¾nÃ© filtrovat nebo tÅ™Ã­dit, byla ve schÃ©matu explicitnÄ› oznaÄena a existoval k
		nim odpovÃ­dajÃ­cÃ­ index. JinÃ½mi slovy, evitaDB nemÃ¡ implementovanÃ½ tzv. <a
			href="https://en.wikipedia.org/wiki/Full_table_scan">full-scan</a>, kterÃ½ je
		rizikem pro kaÅ¾dÃ© produkÄnÃ­ prostÅ™edÃ­ s vÄ›tÅ¡Ã­mi daty a u Å™ady databÃ¡zÃ­ je nÄ›kdy
		i obtÃ­Å¾nÄ› predikovatelnÃ½. VÅ¡echny indexy drÅ¾Ã­ evitaDB v pamÄ›ti aplikace, coÅ¾ na
		jednu stranu zaruÄuje mnohem vyÅ¡Å¡Ã­ rychlost neÅ¾ hledÃ¡nÃ­ v indexu na pevnÃ©m
		disku, ale zÃ¡roveÅˆ pÅ™inÃ¡Å¡Ã­ omezenÃ­ na mnoÅ¾stvÃ­ dat ve vyhledÃ¡vacÃ­ch indexech.
	</p>

	<p>
		Pokud vytvÃ¡Å™Ã­ evitaDB schÃ©ma za chodu, nemÅ¯Å¾e vÄ›dÄ›t, jestli se podle vytvoÅ™enÃ½ch
		dat bude vyhledÃ¡vat Äi tÅ™Ã­dit, a proto preventivnÄ› pro kaÅ¾dÃ½ vytvoÅ™enÃ½ atribut /
		referenci vytvÃ¡Å™Ã­ jak vyhledÃ¡vacÃ­, tak tÅ™Ã­dÃ­cÃ­ index, a tÃ­m pÃ¡dem dochÃ¡zÃ­ k
		velkÃ©mu plÃ½tvÃ¡nÃ­ zdrojÅ¯. U prototypÅ¯ nÃ¡m to asi pÅ™Ã­liÅ¡ nevadÃ­, ale u produkÄnÃ­ho
		kÃ³du si to nemÅ¯Å¾eme dovolit. Proto je vhodnÄ›jÅ¡Ã­ schÃ©ma zaloÅ¾it nÃ¡sledujÃ­cÃ­m
		zpÅ¯sobem:
	</p>

	<pre>// vytvoÅ™Ã­me schÃ©ma novÃ©ho katalogu
evita.defineCatalog("evita-tutorial")
.withDescription("This is a tutorial catalog.")
// specifikujeme schÃ©ma znaÄky
.withEntitySchema(
        "Brand",
        whichIs -> whichIs.withDescription("A manufacturer of products.")
                .withAttribute(
                        "name", String.class,
                        thatIs -> thatIs.localized().filterable().sortable()
                )
)
// specifikujeme schÃ©ma kategorie
.withEntitySchema(
        "Category",
        whichIs -> whichIs.withDescription("A category of products.")
                .withAttribute(
                        "name", String.class,
                        thatIs -> thatIs.localized().filterable().sortable()
                )
                .withHierarchy()
)
// a nakonec i produktu
.withEntitySchema(
        "Product",
        whichIs -> whichIs.withDescription("A product in inventory.")
                .withAttribute(
                        "name", String.class,
                        thatIs -> thatIs.localized().filterable().sortable()
                )
                .withAttribute(
                        "cores", Integer.class,
                        thatIs -> thatIs.withDescription("Number of CPU cores.")
                                .filterable()
                )
                .withAttribute(
                        "graphics", String.class,
                        thatIs -> thatIs.withDescription("Graphics card.")
                                .filterable()
                )
                .withPrice()
                .withReferenceToEntity(
                        "brand", "Brand", Cardinality.EXACTLY_ONE,
                        thatIs -> thatIs.indexed()
                )
                .withReferenceToEntity(
                        "categories", "Category", Cardinality.ZERO_OR_MORE,
                        thatIs -> thatIs.indexed()
                )
)
// teÄ zapÃ­Å¡eme vÅ¡echny definice na server pomocÃ­ sady mutacÃ­
.updateViaNewSession(evita);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.04-define-schema-upfront">https://github.com/FgForrest/evitaDB-tutorial/tree/01.04-define-schema-upfront</a>
		</em>
	</p>

	<p>
		StriktnÃ­ a dynamickÃ½ pÅ™Ã­stup k tvorbÄ› schÃ©matu lze kombinovat pomocÃ­ tzv. <a
			href="https://evitadb.io/documentation/use/schema#evolution">evoluÄnÃ­ch
		reÅ¾imÅ¯</a>, kterÃ© mÃ¡te pod kontrolou jak na Ãºrovni schÃ©ma katalogu, tak i
		jednotlivÃ½ch typÅ¯ entit.
	</p>

	<h3>PÅ™Ã­pravnÃ½ a transakÄnÃ­ reÅ¾im databÃ¡ze</h3>

	<p>
		Smyslem evitaDB je stÃ¡t se sekundÃ¡rnÃ­m ÃºloÅ¾iÅ¡tÄ›m katalogovÃ½ch dat
		optimalizovanÃ½m pro rychlÃ© ÄtenÃ­. VÃ½jimkou je iniciÃ¡lnÃ­ naplnÄ›nÃ­ dat z
		primÃ¡rnÃ­ho ÃºloÅ¾iÅ¡tÄ›, kterÃ© by mÄ›lo bÃ½t v rÃ¡mci moÅ¾nostÃ­ co nejrychlejÅ¡Ã­. Proto
		rozliÅ¡ujeme dvÄ› fÃ¡ze Å¾ivota kaÅ¾dÃ©ho katalogu â€“ pÅ™Ã­pravnÃ½ a transakÄnÃ­. Ve fÃ¡zi
		pÅ™Ã­pravy mÅ¯Å¾e s katalogem pracovat pouze jedinÃ½ klient paralelnÄ› (to nijak
		neomezuje prÃ¡ci jinÃ½ch klientÅ¯ s dalÅ¡Ã­mi katalogy spravovanÃ½mi databÃ¡zÃ­) a
		katalog v tomto reÅ¾imu nepodporuje transakce. DÃ­ky tomu vÅ¡ak mÅ¯Å¾e bÃ½t plnÄ›nÃ­ dat
		mnohem rychlejÅ¡Ã­, protoÅ¾e databÃ¡ze nemusÃ­ Å™eÅ¡it Å¾Ã¡dnou reÅ¾ii spojenou s
		vÃ­cevlÃ¡knovÃ½m pÅ™Ã­stupem a Å™Ã­zenÃ­m transakcÃ­. V tÃ©to fÃ¡zi neexistuje <a
			href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead-log</a> a
		data se zapisujÃ­ rovnou na disk a do indexÅ¯ v pamÄ›ti. Pokud vÅ¡ak dojde k nÄ›jakÃ©
		chybÄ›, nenÃ­ zaruÄena konzistence dat a je nutnÃ© tvorbu katalogu zahÃ¡jit od
		zaÄÃ¡tku.
	</p>

	<p>
		Jakmile je ÃºvodnÃ­ plnÄ›nÃ­ katalogu dokonÄeno, je moÅ¾nÃ© katalog pÅ™epnout do
		transakÄnÃ­ho reÅ¾imu tÃ­mto volÃ¡nÃ­m:
	</p>

	<pre>
evita.updateCatalog(
   "evita-tutorial",
   session -> { session.goLiveAndClose(); }
);
	</pre>

	<p>
		V tu chvÃ­li se stÃ¡vÃ¡ katalog transakÄnÃ­m a je moÅ¾nÃ© nad nÃ­m otevÃ­rat vÃ­ce
		paralelnÃ­ch sezenÃ­ jak pro ÄtenÃ­, tak i pro zÃ¡pis dat. Ãšpravy dat v katalogu
		probÃ­hajÃ­ transakÄnÄ› a dokud nenÃ­ transakce potvrzena (commitnuta), vidÃ­ Ãºpravy
		pouze to sezenÃ­, kterÃ© v danÃ© transakci pracuje. ZÃ¡pisy v transakci se buÄ
		promÃ­tnou do novÃ© verze katalogu ÃºplnÄ›, nebo vÅ¯bec (<a
			href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">atomicity</a>).
		ZÃ¡roveÅˆ je moÅ¾nÃ© kdykoliv provÃ©st tzv. rollback a vÅ¡echny zmÄ›ny v transakci
		zruÅ¡it. ZmÄ›ny provedenÃ© transakcÃ­ A jsou vidÄ›t pouze v transakcÃ­ch zahÃ¡jenÃ½ch po
		potvrzenÃ­ transakce A (tzv. <a
			href="https://en.wikipedia.org/wiki/Snapshot_isolation">snapshot ÃºroveÅˆ
		izolace</a>). Å˜Ã­zenÃ­ transakcÃ­ samozÅ™ejmÄ› vyÅ¾aduje svoji reÅ¾ii, a proto je zÃ¡pis
		dat v tomto reÅ¾imu pomalejÅ¡Ã­ neÅ¾ v pÅ™Ã­pravnÃ©m reÅ¾imu. Na druhou stranu databÃ¡ze
		v tomto reÅ¾imu garantuje poÅ¾adovanÃ© <a
			href="https://en.wikipedia.org/wiki/ACID">ACID</a> vlastnosti, kterÃ© vÃ½vojÃ¡Å™Å¯m
		jednoznaÄnÄ› zjednoduÅ¡ujÃ­ prÃ¡ci.
	</p>

	<h2>ObjektovÄ› relaÄnÃ­ mapovÃ¡nÃ­</h2>

	<p>
		Java vÃ½vojÃ¡Å™i (a nejen ti) majÃ­ pro prÃ¡ci s daty radÅ¡i vlastnÃ­ domÃ©novÄ›
		specifickÃ¡ rozhranÃ­ neÅ¾ generickÃ¡ rozhranÃ­ externÃ­ch knihoven. A majÃ­ pravdu.
		NÃ¡sledujÃ­cÃ­ kÃ³d je pro ÄtenÃ¡Å™e mnohem stravitelnÄ›jÅ¡Ã­:
	</p>

	<pre>Product product = evitaSession.query(...);
assertEquals("VidliÄka na chobotnici", product.getName());
assertEquals("Steelworks", product.getBrand().getName());
assertEquals("345.50", product.getVipPrice().toString());
</pre>

	<p>
		... neÅ¾ tento:
	</p>

	<pre>Product product = evitaSession.query(...);
assertEquals("VidliÄka na chobotnici", product.getAttribute("name"));
assertEquals("Steelworks", product.getReference("brand").getReferencedEntity().getAttribute("name"));
assertEquals("345.50", product.getPrice("vip").toString());
	</pre>

	<p>
		Proto mÃ¡ Java klient (tato funkcionalita nemÃ¡ bohuÅ¾el prozatÃ­m ekvivalent v klientech pro
		evitaDB na ostatnÃ­ch platformÃ¡ch) zabudovanou zÃ¡kladnÃ­ podporu pro interakci s
		aplikaÄnÃ­m kÃ³dem v podobÄ› rozhranÃ­, kterÃ¡ jsou dodanÃ¡ a popsanÃ¡ vÃ½vojÃ¡Å™em.
	</p>

	<p>
		PojÄme si ukÃ¡zat rozhranÃ­, kterÃ© popisuje podobnÃ© schÃ©ma, jako v pÅ™edchozÃ­
		kapitole:
	</p>

	<pre>@Entity(
    name = "Product",
    description = "A product in inventory."
)
public interface Product {

    @Attribute(
            name = "name",
            description = "Name of the product.",
            localized = true,
            filterable = true,
            sortable = true
    )
    @Nonnull
    String getName();

    @Attribute(
            name = "cores",
            description = "Number of CPU cores.",
            filterable = true
    )
    @Nonnull
    Integer getCores();

    @Attribute(
            name = "graphics",
            description = "Graphics card.",
            filterable = true
    )
    @Nonnull
    String getGraphics();

    @Nonnull
    PriceContract getPriceForSale();

    @Reference(
            name = "brand",
            description = "Brand of the product.",
            entity = Brand.ENTITY_NAME,
            allowEmpty = false,
            indexed = true
    )
    @Nonnull
    Brand getBrand();

    @Reference(
            name = "categories",
            description = "Categories the product belongs to.",
            entity = Category.ENTITY_NAME,
            indexed = true
    )
    @Nonnull
    List&lt;Category> getCategories();

}
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract">https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract</a>
		</em>
	</p>

	<p>
		Deklarace tÅ™Ã­dy je zkrÃ¡cena a okolnÃ­ tÅ™Ã­dy jsou vynechÃ¡ny ÃºplnÄ›, ale mÅ¯Å¾ete si
		je snadno dohledat v naÅ¡em ukÃ¡zkovÃ©m repozitÃ¡Å™i. Jakmile mÃ¡me pÅ™ipravenÃ½
		domÃ©novÃ½ model, mÅ¯Å¾eme podle nÄ›j vytvoÅ™it schÃ©ma v katalogu databÃ¡ze:
	</p>

	<pre>evita.updateCatalog(
        "evita-tutorial",
        session -> {
            session.defineEntitySchemaFromModelClass(Brand.class);
            session.defineEntitySchemaFromModelClass(Category.class);
            session.defineEntitySchemaFromModelClass(Product.class);
        }
);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract">https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract</a>
		</em>
	</p>

	<p>
		Ve chvÃ­li, kdy kdy mÃ¡me vytvoÅ™enÃ© schÃ©ma, mÅ¯Å¾eme ta stejnÃ¡ rozhranÃ­ pouÅ¾Ã­t i pro
		pÅ™Ã­stup k datÅ¯m v nÄ›m (a to jak pro zÃ¡pis, tak i pro ÄtenÃ­). Implementace mÅ¯Å¾ete
		samozÅ™ejmÄ› dodat vlastnÃ­m aplikaÄnÃ­m kÃ³dem, nebo je umÃ­ dynamicky generovat
		pÅ™Ã­mo evitaDB. PomocÃ­ knihoven <a href="https://bytebuddy.net/">ByteBuddy</a> a
		<a href="https://github.com/FgForrest/Proxycian">Proxycian</a> vytvoÅ™Ã­
		automaticky generovanÃ© proxy tÅ™Ã­dy implementujÃ­cÃ­ kontrakt entit. Tyto tÅ™Ã­dy
		nebudou tak rychlÃ© jako ruÄnÄ› psanÃ© implementace, ale tento pÅ™Ã­stup nÃ¡m uÅ¡etÅ™Ã­
		spoustu ruÄnÃ­ prÃ¡ce.
	</p>

	<p>
		PojÄme si tedy ukÃ¡zat, jak s pouÅ¾itÃ­m domÃ©novÄ› specifickÃ½ch rozhranÃ­ vytvoÅ™Ã­me
		novou entitu v katalogu:
	</p>

	<pre>final int productId = evita.updateCatalog(
        "evita-tutorial",
        session -> {
            // zaloÅ¾Ã­me novou znaÄku skrze naÅ¡e vlastnÃ­ zÃ¡pisovÃ© rozhranÃ­
            final EntityReference appleBrandRef = session.createNewEntity(BrandEditor.class)
                    .setName("Apple", Locale.ENGLISH)
                    .upsertVia(session);

            // zaloÅ¾Ã­me novou kategorii skrze naÅ¡e vlastnÃ­ zÃ¡pisovÃ© rozhranÃ­
            final EntityReference cellPhonesRef = session.createNewEntity(CategoryEditor.class)
                    .setName("Cell phones", Locale.ENGLISH)
                    .upsertVia(session);

            // a na zÃ¡vÄ›r zaloÅ¾Ã­me produkt, kterÃ½ se bude na vÃ½Å¡e vytvoÅ™enou
            // znaÄku a kategorii odkazovat
            final EntityReference productRef = session.createNewEntity(ProductEditor.class)
                    .setName("iPhone 12", Locale.ENGLISH)
                    .setCores(6)
                    .setGraphics("A14 Bionic")
                    .setBrandId(appleBrandRef.getPrimaryKey())
                    .addCategoryId(cellPhonesRef.getPrimaryKey())
                    .upsertVia(session);
        }

        return productRef.getPrimaryKey();

);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces">https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces</a>
		</em>
	</p>

	<p>
		ZaloÅ¾enÃ½ produkt si mÅ¯Å¾eme na jinÃ©m mÃ­stÄ› pomocÃ­ naÅ¡ich vlastnÃ­ch rozhranÃ­
		naÄÃ­st a vypsat do konzole:
	</p>

	<pre>evita.queryCatalog(
        "evita-tutorial",
        session -> {
            // naÄteme si produkt podle primÃ¡rnÃ­ho klÃ­Äe
            final Product product = session.queryOne(
                            query(
                                    filterBy(
                                            entityPrimaryKeyInSet(productId),
                                            entityLocaleEquals(Locale.ENGLISH)
                                    ),
                                    require(
                                            // Å™ekneme si o tÄ›lo produktu
                                            entityFetch(
                                                    attributeContentAll(),
                                                    // a takÃ© tÄ›lo odkazovanÃ© znaÄky
                                                    referenceContent(
                                                            Product.REFERENCE_BRAND,
                                                            entityFetch(attributeContentAll())
                                                    ),
                                                    // a tÄ›la vÅ¡ech kategoriÃ­ produktu
                                                    referenceContent(
                                                            Product.REFERENCE_CATEGORIES,
                                                            entityFetch(attributeContentAll())
                                                    )
                                            )
                                    )

                            ),
                            Product.class
                    )
                    .orElseThrow(
                            () -> new IllegalStateException("Product with id " + productId + " not found.")
                    );

            // a jeho data vypÃ­Å¡eme do konzole
            System.out.println("Product name: " + product.getName());
            System.out.println("Product cores: " + product.getCores());
            System.out.println("Product graphics: " + product.getGraphics());
            System.out.println("Product brand: " + product.getBrand().getName());
            System.out.println(
                    "Product categories: " +
                            product.getCategories()
                                    .stream()
                                    .map(Category::getName)
                                    .reduce((a, b) -> a + ", " + b)
                                    .orElse("&lt;none>")
            );
        }
);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces">https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces</a>
		</em>
	</p>

	<p>
		A na zÃ¡vÄ›r si ukÃ¡Å¾eme, jak tento produkt upravit a zmÄ›ny uloÅ¾it zpÄ›t do
		databÃ¡ze.
	</p>

	<pre>evita.updateCatalog(
        "evita-tutorial",
        session -> {
            // produkt si zÃ­skÃ¡me stejnÄ› jako pÅ™i bÄ›Å¾nÃ©m ÄtenÃ­
            session.getEntity(
                            Product.class, productId, entityFetchAllContent()
                    )
                    .orElseThrow()
                    // a vytvoÅ™Ã­me si jeho novou oddÄ›lenou "zÃ¡pisovou" instanci
                    .openForWrite()
                    // upravÃ­me potÅ™ebnÃ¡ data
                    .setName("iPhone 12 Pro", Locale.ENGLISH)
                    .setCores(8)
                    // a zmÄ›ny zapÃ­Å¡eme zpÄ›t na databÃ¡zovÃ½ server
                    .upsertVia(session);
        }
);
	</pre>

	<p>
		<em>KompletnÃ­ pÅ™Ã­klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces">https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces</a>
		</em>
	</p>

	<p>
		Na pÅ™Ã­kladu je vidÄ›t, Å¾e pro ÄtenÃ­ a zÃ¡pis mÃ¡me oddÄ›lenÃ¡ rozhranÃ­ (napÅ™. `Brand`
		a `BrandEditor`). AÄkoliv se zdÃ¡ tento pÅ™Ã­stup komplikovanÄ›jÅ¡Ã­ neÅ¾ mÃ­t vÅ¡echny
		(tj. zÃ¡pisovÃ© i ÄtecÃ­) metody na spoleÄnÃ©m rozhranÃ­, mÃ¡ jednu zÃ¡sadnÃ­ vÃ½hodu.
		UmoÅ¾Åˆuje odliÅ¡it instance modelovÃ© tÅ™Ã­dy na vlÃ¡knovÄ› bezpeÄnou imutabilnÃ­
		instanci, kterou mÅ¯Å¾eme bezpeÄnÄ› udrÅ¾ovat tÅ™eba v lokÃ¡lnÃ­ cache a pouÅ¾Ã­vat ji
		souÄasnÄ› z vÃ­ce vlÃ¡ken, a oddÄ›lenou instanci otevÅ™enou pro zÃ¡pis, kterÃ¡ uÅ¾
		vlÃ¡knovÄ› bezpeÄnÃ¡ nenÃ­. KromÄ› toho jsou obÄ› rozhranÃ­ mnohem ÄitelnÄ›jÅ¡Ã­, neÅ¾ kdyÅ¾
		jsou ÄtecÃ­ a zÃ¡pisovÃ© metody na jednÃ© velkÃ© hromadÄ› - coÅ¾ ocenÃ­te pÅ™edevÅ¡Ã­m u
		rozsÃ¡hlejÅ¡Ã­ch modelovÃ½ch rozhranÃ­.
	</p>

	<p>
		PovÅ¡imnÄ›te si, Å¾e aby automatickÃ© generovÃ¡nÃ­ implementacÃ­ fungovalo, je nutnÃ© k
		Java klientovi pÅ™ilinkovat dalÅ¡Ã­ knihovnu:
	</p>

	<pre>&lt;dependency&gt;
   &lt;groupId>one.edee.oss&lt;/groupId&gt;
   &lt;artifactId>proxycian_bytebuddy&lt;/artifactId&gt;
   &lt;version>1.3.10&lt;/version&gt;
&lt;/dependency&gt;
	</pre>

	<p>
		MoÅ¾nosti prÃ¡ce s daty pomocÃ­ vlastnÃ­ch rozhranÃ­ jsou samozÅ™ejmÄ› mnohem Å¡irÅ¡Ã­,
		neÅ¾ nÃ¡m dovoluje zÃ¡bÄ›r tohoto ÄlÃ¡nku, proto si dovolÃ­m ÄtenÃ¡Å™e odkÃ¡zat na
		detailnÄ›jÅ¡Ã­ popis v naÅ¡Ã­ <a
			href="https://evitadb.io/documentation/use/connectors/java?lang=java#custom-contracts">dokumentaci</a>.
		K tÃ©matu se jeÅ¡tÄ› vrÃ¡tÃ­me v nÄ›kterÃ©m z dalÅ¡Ã­ch dÃ­lÅ¯ seriÃ¡lu.
	</p>

	<h2>Kam se podÃ­vÃ¡me pÅ™Ã­Å¡tÄ›?</h2>

	<p>
		V pÅ™Ã­Å¡tÃ­m dÃ­le si ukÃ¡Å¾eme to nejdÅ¯leÅ¾itÄ›jÅ¡Ã­ â€“ zÃ¡kladnÃ­ moÅ¾nosti dotazovacÃ­ho
		jazyka, na kterÃ©m si udÄ›lÃ¡te pÅ™edstavu, v Äem vÃ¡m mÅ¯Å¾e bÃ½t evitaDB uÅ¾iteÄnÃ¡.
		DÃ­ky specializaci na ÃºzkÃ½ segment katalogovÃ½ch Å™eÅ¡enÃ­ je jazyk designovÃ¡n od
		zaÄÃ¡tku tak, aby vÃ¡m umoÅ¾nil rychle vybudovat zÃ¡klad uÅ¾ivatelskÃ©ho rozhranÃ­ pro
		vÃ¡Å¡ e-commerce katalog.
	</p>

	<p>
		Dotazy k ÄlÃ¡nku mÅ¯Å¾ete, kromÄ› diskuze zde na Root.cz, poklÃ¡dat i na naÅ¡em
		<a href="https://discord.gg/VsNBWxgmSw">Discord serveru</a>.
	</p>

</article>
</body>
</html>
