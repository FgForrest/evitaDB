<!--
  ~
  ~                         _ _        ____  ____
  ~               _____   _(_) |_ __ _|  _ \| __ )
  ~              / _ \ \ / / | __/ _` | | | |  _ \
  ~             |  __/\ V /| | || (_| | |_| | |_) |
  ~              \___| \_/ |_|\__\__,_|____/|____/
  ~
  ~   Copyright (c) 2024
  ~
  ~   Licensed under the Business Source License, Version 1.1 (the "License");
  ~   you may not use this file except in compliance with the License.
  ~   You may obtain a copy of the License at
  ~
  ~   https://github.com/FgForrest/evitaDB/blob/main/LICENSE
  ~
  ~   Unless required by applicable law or agreed to in writing, software
  ~   distributed under the License is distributed on an "AS IS" BASIS,
  ~   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~   See the License for the specific language governing permissions and
  ~   limitations under the License.
  -->

<!DOCTYPE html>
<html lang="cs">
<head>
	<meta charset="UTF-8">
	<title>evitaDB ‚Äì spu≈°tƒõn√≠, definice sch√©matu a naplnƒõn√≠ daty</title>
</head>
<body>
<header>
	<h1>evitaDB ‚Äì spu≈°tƒõn√≠, definice sch√©matu a naplnƒõn√≠ daty</h1>
	<time datetime="2024-01-14">14. ledna 2024</time>
	<p>
		V tomto d√≠lu si p≈ôedstav√≠me, jak jsou data v evitaDB organizov√°na, vysvƒõtl√≠me si z√°kladn√≠ pojmy jako jsou
		katalog, typ entity a sch√©ma. Vyzkou≈°√≠me si zalo≈æit nov√Ω katalog a souvisej√≠c√≠ sch√©mata v datab√°zi a naplnit
		ji z√°kladn√≠mi daty.
	</p>
</header>
<article>

	<p>
		Pojƒème si na √∫vod uk√°zat, jak√© mo≈ænosti provozov√°n√≠ evitaDB nab√≠z√≠. Datab√°ze je
		bƒõ≈æn√° Java aplikace (JAR), kterou je mo≈æn√© zabalit a provozovat v r√°mci jin√©
		Java aplikace (tzv. embedded re≈æim) nebo je mo≈æn√© ji spustit jako samostatn√Ω
		proces, kter√Ω lze n√°slednƒõ pou≈æ√≠vat z libovoln√© jin√© aplikace (a jazykov√©
		platformy). Pro zjednodu≈°en√≠ instalace je p≈ôipraven√Ω Docker image, kter√Ω
		obsahuje jak datab√°zov√Ω program, tak i spr√°vnou verzi virtu√°ln√≠ho stroje Java a
		podkladov√Ω operaƒçn√≠ syst√©m. V tomto ƒçl√°nku budeme pou≈æ√≠vat pouze variantu
		spu≈°tƒõn√≠ evitaDB jako Docker kontejneru ‚Äì‚Å† ostatn√≠ zp≈Øsoby jsou pops√°ny v <a
			href="https://evitadb.io/documentation/get-started/run-evitadb?codelang=evitaql">dokumentaci</a>.
	</p>
	<h2>Zprovoznƒõn√≠ Docker kontejneru</h2>
	<p>
		Ke spu≈°tƒõn√≠ datab√°ze tedy budete pot≈ôebovat m√≠t na sv√©m lok√°ln√≠m v√Ωvojov√©m
		prost≈ôed√≠ nainstalovan√Ω <a
			href="https://docs.docker.com/engine/install/">Docker</a>. N√°slednƒõ staƒç√≠
		spustit tento p≈ô√≠kaz:
	</p>

	<pre>docker run --name evitadb -i --rm --net=host \
       -e "api.exposedOn=localhost" \
       index.docker.io/evitadb/evitadb:latest
	</pre>

	<p>
		T√≠m si st√°hnete aktu√°ln√≠ verzi datab√°ze, vytvo≈ô√≠te si lok√°lnƒõ kontejner s n√°zvem
		‚Äûevitadb‚Äú a nasd√≠l√≠te mu lok√°ln√≠ s√≠≈• va≈°eho poƒç√≠taƒçe. Kontejner se spust√≠ v
		interaktivn√≠m re≈æimu, tak≈æe uvid√≠te v√Ωstup jeho konzole a bude jej moci zastavit
		pomoc√≠ kombinace kl√°ves Ctrl+C. Pokud datab√°zi pou≈°t√≠te na jin√©m operaƒçn√≠m
		syst√©mu jak Linux, budete pot≈ôebovat ponƒõkud slo≈æitƒõj≈°√≠ variantu spu≈°tƒõn√≠ s
		manu√°ln√≠m mapov√°n√≠m port≈Ø (alespo≈à do t√© doby ne≈æ Docker vy≈ôe≈°√≠ <a
			href="https://github.com/docker/roadmap/issues/238">issue #238</a>):
	</p>

	<pre>docker run --name evitadb -i --rm -p 5555:5555 -p 5556:5556 -p 5557:5557 \
       -e "api.exposedOn=localhost" \
       index.docker.io/evitadb/evitadb:latest
	</pre>

	<p>
		Po nastartov√°n√≠ uvid√≠te v√Ωstup na konzoli podobn√Ω tomuto:
	</p>

	<pre>            _ _        ____  ____
  _____   _(_) |_ __ _|  _ \| __ )
 / _ \ \ / / | __/ _` | | | |  _ \
|  __/\ V /| | || (_| | |_| | |_) |
 \___| \_/ |_|\__\__,_|____/|____/

beta build 2024.6.1 (keep calm and report bugs üòâ)
Visit us at: https://evitadb.io

Log config used: META-INF/logback.xml (original file `/evita/logback.xml` doesn't exist)
Server name: evitaDB-b493e0c4c8d06865
17:37:54.253 INFO  i.e.e.g.GraphQLManager - Built GraphQL API in 0.000000151s
17:37:54.305 INFO  i.e.e.r.RestManager - Built REST API in 0.000000048s
17:37:54.924 INFO  i.e.e.l.LabManager - Built Lab in 0.000000062s
Root CA Certificate fingerprint:        C2:62:C6:B7:97:B1:B6:82:08:D0:C6:5F:2F:0B:A1:EA:F7:A2:01:08:C3:7C:20:60:CC:02:7C:1E:5F:F1:57:B3
API `graphQL` listening on              https://localhost:5555/gql/, https://d651d19eee1a:5555/gql/
API `rest` listening on                 https://localhost:5555/rest/, https://d651d19eee1a:5555/rest/
API `gRPC` listening on                 https://localhost:5556/, https://d651d19eee1a:5556/
API `system` listening on               http://localhost:5557/system/, http://d651d19eee1a:5557/system/
   - server name served at:             http://localhost:5557/system/server-name, http://d651d19eee1a:5557/system/server-name
   - CA certificate served at:          http://localhost:5557/system/evitaDB-CA-selfSigned.crt, http://d651d19eee1a:5557/system/evitaDB-CA-selfSigned.crt
   - server certificate served at:      http://localhost:5557/system/server.crt, http://d651d19eee1a:5557/system/server.crt
   - client certificate served at:      http://localhost:5557/system/client.crt, http://d651d19eee1a:5557/system/client.crt
   - client private key served at:      http://localhost:5557/system/client.key, http://d651d19eee1a:5557/system/client.key

************************* WARNING!!! *************************
You use mTLS with automatically generated client certificate.
This is not safe for production environments!
Supply the certificate for production manually and set `useGeneratedCertificate` to false.
************************* WARNING!!! *************************

API `lab` listening on                  https://localhost:5555/lab/, https://d651d19eee1a:5555/lab/
</pre>

	<p>
		Z v√Ωpisu je patrn√©, ≈æe evitaDB nastartovala nƒõkolik s√≠≈•ov√Ωch rozhran√≠, kter√©
		m√°te nyn√≠ na sv√©m poƒç√≠taƒçi dostupn√©:
	</p>

	<ul>
		<li>rozhran√≠ s GraphQL protokolem,
		<li>rozhran√≠ s REST protokolem,
		<li>rozhran√≠ s gRPC protokolem,
		<li>syst√©mov√© rozhran√≠, jeho≈æ √∫ƒçel v tomto seri√°lu rozeb√≠rat nebudeme,
		<li>a u≈æivatelsk√© rozhran√≠ pro p≈ô√≠stup k dat≈Øm (laborato≈ô)
		</li>
	</ul>

	<p>
		Jak je vidno, rozhran√≠ nastartovala jsou dostupn√° v≈ædy na dvou adres√°ch ‚Äì jedn√©
		s n√°hodnƒõ generovan√Ωm n√°zvem hostname, kter√° je dostupn√° pouze zevnit≈ô Docker
		kontejneru a druh√° s n√°zvem ‚Äúlocalhost‚Äù, kter√° bude fungovat z va≈°eho lok√°ln√≠ho
		prost≈ôed√≠. Jejich funkƒçnost si m≈Ø≈æete ovƒõ≈ôit jednoduch√Ωm zp≈Øsobem:
	</p>

	<p>
		<strong>GraphQL:</strong>
	</p>

	<pre>curl -k -X POST "https://localhost:5555/gql/system" \
  -H 'Content-Type: application/json' \
  -d '{"query":"{alive}"}'
	</pre>

	<p>
		<strong>REST:</strong>
	</p>

	<pre>curl -k "https://localhost:5555/rest/system/liveness" \
  -H 'Content-Type: application/json'
	</pre>

	<p>
		P≈ô√≠padnƒõ m≈Ø≈æete samoz≈ôejmƒõ rozkliknout odkaz `lab` rozhran√≠ a po odkliknut√≠
		varov√°n√≠ o ned≈Øvƒõryhodn√©m (self-signed) certifik√°tu a nechat si zobrazit √∫vodn√≠
		obrazovku na≈°√≠ laborato≈ôe.
	</p>

	<h2>Pr√°ce s datab√°z√≠ z Java klienta</h2>

	<p>
		V na≈°em seri√°lu budeme popisovat p≈ôedev≈°√≠m pr√°ci s datab√°z√≠ z Java prost≈ôed√≠. To
		v≈°ak neznamen√°, ≈æe to je cesta jedin√° mo≈æn√°. Kromƒõ Java klienta je k dispozici i
		klientsk√° knihovna pro C# a na ostatn√≠ch platform√°ch je mo≈æn√© zaƒç√≠t s
		vygenerovan√Ωm k√≥dem na z√°kladƒõ publikovan√Ωch webov√Ωch sch√©mat (GraphQL, Open
		API, gRPC sch√©ma). Plnohodnotn√° klientsk√° knihovna v≈°ak p≈ôin√°≈°√≠ lep≈°√≠ komfort
		p≈ôedev≈°√≠m p≈ôi vytv√°≈ôen√≠ datab√°zov√Ωch sch√©mat a aktualizaci dat v datab√°zi.
		V≈°echny souƒçasn√© klientsk√© knihovny stav√≠ na protokolu gRPC a vƒõ≈ô√≠me, ≈æe ƒçasem
		vzniknou porty pro dal≈°√≠ programovac√≠ jazyky (nap≈ô. PHP ƒçi Node.js).
	</p>

	<p>
		Pro napojen√≠ na evitaDB z Java aplikace, je pot≈ôeba si nejd≈ô√≠ve nalinkovat
		klientskou knihovnu. V buildovac√≠m prost≈ôed√≠ Maven staƒç√≠ p≈ôidat tuto z√°vislost:
	</p>

	<pre>&lt;dependency&gt;
    &lt;groupId>io.evitadb&lt;/groupId&gt;
    &lt;artifactId>evita_db&lt;/artifactId&gt;
    &lt;version>10.1.1&lt;/version&gt;
    &lt;type>pom&lt;/type&gt;
&lt;/dependency&gt;
	</pre>

	<p>
		V Java aplikaci pak staƒç√≠ u≈æ jen inicializovat klienta:
	</p>

	<pre>
EvitaContract evita = new EvitaClient(
   EvitaClientConfiguration.builder()
                           .host("localhost")
                           .port(5556)
                           .build()
);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.01-connect-evitadb">https://github.com/FgForrest/evitaDB-tutorial/tree/01.01-connect-evitadb</a>
		</em>
	</p>

	<p>
		P≈ôi pr√°ci s evitaDB je vhodn√© pou≈æ√≠vat obecn√° rozhran√≠, kter√© maj√≠ p≈ô√≠ponu
		`Contract` ‚Äì v tomto p≈ô√≠padƒõ tedy `EvitaContract`. Umo≈æn√≠ v√°m to jednodu≈°e
		p≈ôep√≠nat mezi provozem datab√°ze embedovanƒõ (tj. souƒç√°st√≠ va≈°√≠ aplikace) a
		vzd√°lenƒõ. To ocen√≠te p≈ôedev≈°√≠m p≈ôi psan√≠ automatizovan√Ωch integraƒçn√≠ch test≈Ø.
	</p>

	<h3>Katalog a jeho zalo≈æen√≠</h3>

	<p>
		Proto≈æe se evitaDB specializuje na katalogov√° ≈ôe≈°en√≠, je z√°kladn√≠m stavebn√≠m
		blokem tzv. katalog. Smyslem katalogu je zapouzd≈ôit v≈°echna data spojen√° s
		jednou ‚Äûaplikac√≠‚Äú ƒçi ‚Äû<a
			href="https://en.wikipedia.org/wiki/Multitenancy">tenantem</a>‚Äú a izolovat je od
		ostatn√≠ch katalog≈Ø.
	</p>

	<p>
		Nov√Ω katalog zalo≈æ√≠me n√°sleduj√≠c√≠m p≈ô√≠kazem:
	</p>

	<pre>
evita.defineCatalog("evita-tutorial");
	</pre>

	<p>
		Pokud chceme katalogu rovnou nastavit nƒõjak√Ω popis, tedy aktualizovat jeho
		sch√©ma, bude n√°≈° k√≥d o nƒõco del≈°√≠:
	</p>

	<pre>
evita.defineCatalog("evita-tutorial")
     .withDescription("This is a tutorial catalog.")
     .updateViaNewSession(evita);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.02-setup-new-catalog">https://github.com/FgForrest/evitaDB-tutorial/tree/01.02-setup-new-catalog</a>
		</em>
	</p>

	<h3>Kolekce entit a jejich sch√©ma</h3>

	<p>
		Katalog obsahuje jeden nebo v√≠ce typ≈Ø entit organizovan√Ωch v kolekc√≠ch. Typ
		entity odpov√≠d√° v pojet√≠ relaƒçn√≠ datab√°ze sadƒõ tabulek, kter√© maj√≠ logickou
		souvislost. V dokumentov√Ωch datab√°z√≠ch je analogi√≠ kolekce (nap≈ô. MongoDB) nebo
		index (nap≈ô. Elasticsearch).
	</p>

	<p>
		Ka≈æd√° entita je unik√°tnƒõ identifikovan√° sv√Ωm prim√°rn√≠m kl√≠ƒçem, kter√Ω m≈Ø≈æe
		p≈ôidƒõlovat buƒè sama datab√°ze, nebo m≈Ø≈æe b√Ωt dodan√Ω p≈ôi vkl√°d√°n√≠ dat aplikac√≠.
		Prim√°rn√≠m kl√≠ƒçem je datov√Ω typ 32-bitov√Ω integer, ale aplikace m≈Ø≈æe pro sv√©
		byznysov√© kl√≠ƒçe pou≈æ√≠vat typ UUID a ten pou≈æ√≠vat jako hlavn√≠ identifik√°tor
		entity. D≈Øvody pro pou≈æit√≠ datov√©ho typu pro prim√°rn√≠ kl√≠ƒç jsou podrobnƒõji
		pops√°ny v <a
			href="https://evitadb.io/documentation/use/data-model?codelang=graphql#primary-key">dokumentaci</a>.
	</p>

	<p>
		Entita m≈Ø≈æe d√°le obsahovat tyto z√°kladn√≠ bloky dat:
	</p>

	<ul>
		<li><strong>Atributy:</strong> sada kombinac√≠ kl√≠ƒç/√∫daj, kde kl√≠ƒçem je n√°zev
			atributu (`String`) a √∫dajem je jedna nebo v√≠ce (pole) hodnot <a
					href="https://evitadb.io/documentation/use/data-types?codelang=evitaql">povolen√Ωch
				datov√Ωch typ≈Ø</a>; atributy se ukl√°daj√≠ a naƒç√≠taj√≠ v r√°mci jednoho spoleƒçn√©ho
			datov√©ho bloku a mƒõly by b√Ωt vyu≈æ√≠v√°ny k ukl√°d√°n√≠ dat, ke kter√Ωm se v
			souvislosti s entitou velmi ƒçasto p≈ôistupuje nebo kter√© slou≈æ√≠ k filtrov√°n√≠ ƒçi
			t≈ô√≠dƒõn√≠
		<li><strong>Asociovan√° data:</strong> sada kombinac√≠ kl√≠ƒç/√∫daj, kde kl√≠ƒçem je
			≈ôetƒõzec n√°zvu (`String`) a √∫dajem je jedna nebo v√≠ce (pole) hodnot <a
					href="https://evitadb.io/documentation/use/data-types?codelang=evitaql">povolen√Ωch
				datov√Ωch typ≈Ø</a>, ƒçi komplexn√≠ objektov√° struktura (analogie k JSON typu);
			asociovan√° data by mƒõla b√Ωt vyu≈æ√≠v√°na pro v≈°echna data, kter√° se vyu≈æ√≠vaj√≠ jen
			z≈ô√≠dka a jsou ukl√°d√°na ka≈æd√° v samostatn√©m datov√©m bloku (naƒç√≠taj√≠ se
			jednotlivƒõ).
		<li><strong>Ceny:</strong> pevnƒõ dan√° struktura cen obsahuj√≠c√≠ p≈ôedev≈°√≠m:
			<ul>
				<li>cenu bez a s dan√≠, procento danƒõ,
				<li>n√°zev cen√≠ku (`String`),
				<li>vlastn√≠ identifik√°tor pro √∫ƒçely synchronizace s extern√≠mi syst√©my,
				<li>ƒçasovou platnost,
				<li>p≈ô√≠znak, zda se jedn√° o prodejn√≠ cenu (indexovanou pro vyhled√°v√°n√≠)
				</li>
			</ul>
		<li><strong>Hierarchie:</strong> prim√°rn√≠ kl√≠ƒç nad≈ô√≠zen√© entity ve stromov√©
			struktu≈ôe stejn√©ho typu entity. Entity potom tvo≈ô√≠ acyklick√Ω orientovan√Ω graf s
			‚Äûvirtu√°ln√≠m ko≈ôenem‚Äú, ke kter√©mu se vztahuj√≠ entity, kter√© nemaj√≠ definovan√Ω
			sv≈Øj nad≈ô√≠zen√Ω uzel.
		<li><strong>Reference:</strong> sada ukazatel≈Ø na jin√© entity stejn√©ho nebo
			jin√©ho typu; ukazatel m≈Ø≈æe smƒõ≈ôovat i na entitu, kter√° nen√≠ souƒç√°st√≠ katalogu
			evitaDB (m≈Ø≈æe se jednat o entitu v extern√≠m syst√©mu, kterou nen√≠ vhodn√©
			duplikovat do evitaDB, ale chceme ji zapojit do v√Ωpoƒçt≈Ø, kter√© evitaDB s
			referencemi umo≈æ≈àuje) ‚Äì o mo≈æn√Ωch v√Ωpoƒçtech se dozv√≠te v dal≈°√≠ch kapitol√°ch
			tohoto seri√°lu.
			<ul>
				<li><strong>Skupina:</strong> voliteln√Ω ukazatel na jinou entitu, kter√Ω umo≈æ≈àuje
					seskupovat reference do logick√Ωch blok≈Ø, pro kter√Ω plat√≠ stejn√° pravidla jako
					pro referenci samotnou (v√Ωsledky v√Ωpoƒçt≈Ø nad referencemi budou v≈ædy respektovat
					rozlo≈æen√≠ dle t√©to skupiny).
				<li><strong>Atributy referenc√≠:</strong> sada kombinac√≠ kl√≠ƒç/√∫daj, kde kl√≠ƒçem je
					n√°zev atributu (`String`) a √∫dajem je jedna nebo v√≠ce (pole) hodnot <a
							href="https://evitadb.io/documentation/use/data-types?codelang=evitaql">povolen√Ωch
						datov√Ωch typ≈Ø</a>; atributy se ukl√°daj√≠ a naƒç√≠taj√≠ v r√°mci spoleƒçn√©ho datov√©ho
					bloku s referencemi a c√≠l√≠ na informace, kter√© d√°vaj√≠ smysl pouze v souvislosti
					s touto referenc√≠ (obdoba sloupc≈Ø na vazebn√≠ tabulce v relaƒçn√≠ datab√°zi).
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Popis struktury entity je zjednodu≈°en√Ω. ≈òadu dal≈°√≠ch detail≈Ø a d≈Øvod≈Ø pro
		existenci tƒõchto z√°kladn√≠ch blok≈Ø se doƒçtete v <a
			href="https://evitadb.io/documentation/use/data-model?codelang=evitaql">dokumentaci</a>.
	</p>
	<p>
		Entitu popisuje jej√≠ sch√©ma. Sch√©ma je datab√°zi v≈ædy striktnƒõ kontrolov√°no, ale
		m≈Ø≈æe vznikat dynamicky na z√°kladƒõ prvn√≠ch dat v dan√© kolekci. Pojƒème si tedy
		velmi rychle naprototypovat nƒõjak√Ω z√°kladn√≠ model pro jednoduch√Ω e-commerce
		katalog:
	</p>

	<pre>// vytvo≈ô√≠me nov√© sch√©ma t√≠m, ≈æe rovnou zad√°me uk√°zkov√° data
evita.updateCatalog(
        "evita-tutorial",
        session -> {
            // nejd≈ô√≠v vytvo≈ô√≠me znaƒçku Lenovo
            session.createNewEntity("Brand", 1)
                    .setAttribute("name", Locale.ENGLISH, "Lenovo")
                    .upsertVia(session);

            // pak nƒõkolik kategori√≠ navz√°jem spojen√Ωch do stromu
            session.createNewEntity("Category", 10)
                    .setAttribute("name", Locale.ENGLISH, "Electronics")
                    .upsertVia(session);

            session.createNewEntity("Category", 11)
                    .setAttribute("name", Locale.ENGLISH, "Laptops")
                    // laptopy budou pod≈ô√≠zenou kategori√≠ elektroniky
                    .setParent(10)
                    .upsertVia(session);

            // a nakonec vytvo≈ô√≠me produkt
            session.createNewEntity("Product")
                    // s nƒõkolika atributy
                    .setAttribute("name", Locale.ENGLISH, "ThinkPad P15 Gen 1")
                    .setAttribute("cores", 8)
                    .setAttribute("graphics", "NVIDIA Quadro RTX 4000 with Max-Q Design")
                    // a prodejn√≠ cenou
                    .setPrice(
                            1, "basic",
                            Currency.getInstance("USD"),
                            new BigDecimal("1420"), new BigDecimal("20"), new BigDecimal("1704"),
                            true
                    )
                    // spoj√≠me jej s v√Ωrobcem
                    .setReference(
                            "brand", "Brand",
                            Cardinality.EXACTLY_ONE,
                            1
                    )
                    // a za≈ôad√≠me do kategorie
                    .setReference(
                            "categories", "Category",
                            Cardinality.ZERO_OR_MORE,
                            11
                    )
                    .upsertVia(session);
        }
);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.03-define-schema-on-the-fly">https://github.com/FgForrest/evitaDB-tutorial/tree/01.03-define-schema-on-the-fly</a></em>
	</p>

	<p>
		Vytv√°≈ôen√≠ nov√Ωch entit pou≈æ√≠v√° tzv. ‚Äû<a
			href="https://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a>‚Äú, kter√Ω
		shroma≈æƒèuje v≈°echny zmƒõny na dan√© entitƒõ a v z√°vƒõreƒçn√©m vol√°n√≠ metody
		`upsertVia(session)` vytvo≈ô√≠ seznam pot≈ôebn√Ωch mutac√≠, kter√© prost≈ôednictv√≠m
		p≈ôedan√©ho sezen√≠ po≈°le na server, kde se zalo≈æ√≠ odpov√≠daj√≠c√≠ datov√© struktury
		(pro lep≈°√≠ p≈ôedstavu o tom, co se dƒõje pod kapotou vyzkou≈°ejte m√≠sto t√©to
		metody: `toInstance()` ƒçi `toMutations()`).
	</p>

	<p>
		Pokud chcete m√≠t rychle vizu√°ln√≠ zpƒõtnou vazbu, co jste v datab√°zi pr√°vƒõ
		provedli, pou≈æijte n√°stroj <a href="https://demo.evitadb.io">evitaLab</a>, kter√Ω
		v√°m nastartuje spoleƒçnƒõ s datab√°z√≠ (pokud jej nezak√°≈æete v konfiguraci). Odkaz
		na verzi, kter√° bƒõ≈æ√≠ spoleƒçnƒõ s va≈°√≠ datab√°z√≠, se zobraz√≠ po startu Docker
		kontejneru v konzoli a automaticky v√°m umo≈æn√≠ p≈ô√≠stup k lok√°ln√≠m dat≈Øm v
		datab√°zi.
	</p>

	<p>
		Stejnƒõ tak m≈Ø≈æete nad va≈°√≠m modelem okam≈æitƒõ vyzkou≈°et v≈°echna podporovan√° API:
		<a href="https://evitadb.io/documentation/use/connectors/grpc">gRPC</a>, <a
			href="https://evitadb.io/documentation/use/connectors/graphql">GraphQL</a> nebo
		<a href="https://evitadb.io/documentation/use/connectors/rest">REST</a>. Nebo si
		podle vypublikovan√Ωch sch√©mat (pro REST jsme zvolili cestu Open API) vygenerovat
		kostru (stub) klientsk√©ho k√≥du, kter√Ω bude s daty pracovat. O tƒõchto webov√Ωch
		API si ale pov√≠me v nƒõkter√©m z dal≈°√≠ch d√≠l≈Ø seri√°lu.
	</p>

	<h4><em>Nechce se v√°m p≈ôepisovat k√≥d z ƒçl√°nku do sv√©ho IDE?</em></h4>
	<p>
		<em>V≈°echny p≈ô√≠klady, kter√© budeme popisovat v t√©to s√©rii ƒçl√°nk≈Ø najdete v <a
				href="https://github.com/FgForrest/evitaDB-tutorial">uk√°zkov√©m GitHub
			repository</a>, kde jsou zdrojov√© k√≥dy pro jednotliv√© ƒçl√°nky v s√©rii dostupn√© v
			samostatn√Ωch vƒõtv√≠ch. Staƒç√≠, kdy≈æ si provedete `checkout` odpov√≠daj√≠c√≠ vƒõtve a
			najdete si tu spr√°vnou metodu v testovac√≠ sadƒõ. N√°slednƒõ u≈æ m≈Ø≈æete
			experimentovat dle sv√© libosti.</em>
	</p>

	<p>
		Aƒçkoliv je tento p≈ô√≠stup l√°kav√Ω pro rychl√© prototypov√°n√≠, pro seri√≥zn√≠ v√Ωvoj se
		p≈ô√≠li≈° nehod√≠. evitaDB striktnƒõ vy≈æaduje, aby v≈°echna data, podle kter√Ωch je
		mo≈æn√© filtrovat nebo t≈ô√≠dit, byla ve sch√©matu explicitnƒõ oznaƒçena a existoval k
		nim odpov√≠daj√≠c√≠ index. Jin√Ωmi slovy, evitaDB nem√° implementovan√Ω tzv. <a
			href="https://en.wikipedia.org/wiki/Full_table_scan">full-scan</a>, kter√Ω je
		rizikem pro ka≈æd√© produkƒçn√≠ prost≈ôed√≠ s vƒõt≈°√≠mi daty a u ≈ôady datab√°z√≠ je nƒõkdy
		i obt√≠≈ænƒõ predikovateln√Ω. V≈°echny indexy dr≈æ√≠ evitaDB v pamƒõti aplikace, co≈æ na
		jednu stranu zaruƒçuje mnohem vy≈°≈°√≠ rychlost ne≈æ hled√°n√≠ v indexu na pevn√©m
		disku, ale z√°rove≈à p≈ôin√°≈°√≠ omezen√≠ na mno≈æstv√≠ dat ve vyhled√°vac√≠ch indexech.
	</p>

	<p>
		Pokud vytv√°≈ô√≠ evitaDB sch√©ma za chodu, nem≈Ø≈æe vƒõdƒõt, jestli se podle vytvo≈ôen√Ωch
		dat bude vyhled√°vat ƒçi t≈ô√≠dit, a proto preventivnƒõ pro ka≈æd√Ω vytvo≈ôen√Ω atribut /
		referenci vytv√°≈ô√≠ jak vyhled√°vac√≠, tak t≈ô√≠d√≠c√≠ index, a t√≠m p√°dem doch√°z√≠ k
		velk√©mu pl√Ωtv√°n√≠ zdroj≈Ø. U prototyp≈Ø n√°m to asi p≈ô√≠li≈° nevad√≠, ale u produkƒçn√≠ho
		k√≥du si to nem≈Ø≈æeme dovolit. Proto je vhodnƒõj≈°√≠ sch√©ma zalo≈æit n√°sleduj√≠c√≠m
		zp≈Øsobem:
	</p>

	<pre>// vytvo≈ô√≠me sch√©ma nov√©ho katalogu
evita.defineCatalog("evita-tutorial")
.withDescription("This is a tutorial catalog.")
// specifikujeme sch√©ma znaƒçky
.withEntitySchema(
        "Brand",
        whichIs -> whichIs.withDescription("A manufacturer of products.")
                .withAttribute(
                        "name", String.class,
                        thatIs -> thatIs.localized().filterable().sortable()
                )
)
// specifikujeme sch√©ma kategorie
.withEntitySchema(
        "Category",
        whichIs -> whichIs.withDescription("A category of products.")
                .withAttribute(
                        "name", String.class,
                        thatIs -> thatIs.localized().filterable().sortable()
                )
                .withHierarchy()
)
// a nakonec i produktu
.withEntitySchema(
        "Product",
        whichIs -> whichIs.withDescription("A product in inventory.")
                .withAttribute(
                        "name", String.class,
                        thatIs -> thatIs.localized().filterable().sortable()
                )
                .withAttribute(
                        "cores", Integer.class,
                        thatIs -> thatIs.withDescription("Number of CPU cores.")
                                .filterable()
                )
                .withAttribute(
                        "graphics", String.class,
                        thatIs -> thatIs.withDescription("Graphics card.")
                                .filterable()
                )
                .withPrice()
                .withReferenceToEntity(
                        "brand", "Brand", Cardinality.EXACTLY_ONE,
                        thatIs -> thatIs.indexed()
                )
                .withReferenceToEntity(
                        "categories", "Category", Cardinality.ZERO_OR_MORE,
                        thatIs -> thatIs.indexed()
                )
)
// teƒè zap√≠≈°eme v≈°echny definice na server pomoc√≠ sady mutac√≠
.updateViaNewSession(evita);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.04-define-schema-upfront">https://github.com/FgForrest/evitaDB-tutorial/tree/01.04-define-schema-upfront</a>
		</em>
	</p>

	<p>
		Striktn√≠ a dynamick√Ω p≈ô√≠stup k tvorbƒõ sch√©matu lze kombinovat pomoc√≠ tzv. <a
			href="https://evitadb.io/documentation/use/schema#evolution">evoluƒçn√≠ch
		re≈æim≈Ø</a>, kter√© m√°te pod kontrolou jak na √∫rovni sch√©ma katalogu, tak i
		jednotliv√Ωch typ≈Ø entit.
	</p>

	<h3>P≈ô√≠pravn√Ω a transakƒçn√≠ re≈æim datab√°ze</h3>

	<p>
		Smyslem evitaDB je st√°t se sekund√°rn√≠m √∫lo≈æi≈°tƒõm katalogov√Ωch dat
		optimalizovan√Ωm pro rychl√© ƒçten√≠. V√Ωjimkou je inici√°ln√≠ naplnƒõn√≠ dat z
		prim√°rn√≠ho √∫lo≈æi≈°tƒõ, kter√© by mƒõlo b√Ωt v r√°mci mo≈ænost√≠ co nejrychlej≈°√≠. Proto
		rozli≈°ujeme dvƒõ f√°ze ≈æivota ka≈æd√©ho katalogu ‚Äì p≈ô√≠pravn√Ω a transakƒçn√≠. Ve f√°zi
		p≈ô√≠pravy m≈Ø≈æe s katalogem pracovat pouze jedin√Ω klient paralelnƒõ (to nijak
		neomezuje pr√°ci jin√Ωch klient≈Ø s dal≈°√≠mi katalogy spravovan√Ωmi datab√°z√≠) a
		katalog v tomto re≈æimu nepodporuje transakce. D√≠ky tomu v≈°ak m≈Ø≈æe b√Ωt plnƒõn√≠ dat
		mnohem rychlej≈°√≠, proto≈æe datab√°ze nemus√≠ ≈ôe≈°it ≈æ√°dnou re≈æii spojenou s
		v√≠cevl√°knov√Ωm p≈ô√≠stupem a ≈ô√≠zen√≠m transakc√≠. V t√©to f√°zi neexistuje <a
			href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead-log</a> a
		data se zapisuj√≠ rovnou na disk a do index≈Ø v pamƒõti. Pokud v≈°ak dojde k nƒõjak√©
		chybƒõ, nen√≠ zaruƒçena konzistence dat a je nutn√© tvorbu katalogu zah√°jit od
		zaƒç√°tku.
	</p>

	<p>
		Jakmile je √∫vodn√≠ plnƒõn√≠ katalogu dokonƒçeno, je mo≈æn√© katalog p≈ôepnout do
		transakƒçn√≠ho re≈æimu t√≠mto vol√°n√≠m:
	</p>

	<pre>
evita.updateCatalog(
   "evita-tutorial",
   session -> { session.goLiveAndClose(); }
);
	</pre>

	<p>
		V tu chv√≠li se st√°v√° katalog transakƒçn√≠m a je mo≈æn√© nad n√≠m otev√≠rat v√≠ce
		paraleln√≠ch sezen√≠ jak pro ƒçten√≠, tak i pro z√°pis dat. √öpravy dat v katalogu
		prob√≠haj√≠ transakƒçnƒõ a dokud nen√≠ transakce potvrzena (commitnuta), vid√≠ √∫pravy
		pouze to sezen√≠, kter√© v dan√© transakci pracuje. Z√°pisy v transakci se buƒè
		prom√≠tnou do nov√© verze katalogu √∫plnƒõ, nebo v≈Øbec (<a
			href="https://en.wikipedia.org/wiki/Atomicity_(database_systems)">atomicity</a>).
		Z√°rove≈à je mo≈æn√© kdykoliv prov√©st tzv. rollback a v≈°echny zmƒõny v transakci
		zru≈°it. Zmƒõny proveden√© transakc√≠ A jsou vidƒõt pouze v transakc√≠ch zah√°jen√Ωch po
		potvrzen√≠ transakce A (tzv. <a
			href="https://en.wikipedia.org/wiki/Snapshot_isolation">snapshot √∫rove≈à
		izolace</a>). ≈ò√≠zen√≠ transakc√≠ samoz≈ôejmƒõ vy≈æaduje svoji re≈æii, a proto je z√°pis
		dat v tomto re≈æimu pomalej≈°√≠ ne≈æ v p≈ô√≠pravn√©m re≈æimu. Na druhou stranu datab√°ze
		v tomto re≈æimu garantuje po≈æadovan√© <a
			href="https://en.wikipedia.org/wiki/ACID">ACID</a> vlastnosti, kter√© v√Ωvoj√°≈ô≈Øm
		jednoznaƒçnƒõ zjednodu≈°uj√≠ pr√°ci.
	</p>

	<h2>Objektovƒõ relaƒçn√≠ mapov√°n√≠</h2>

	<p>
		Java v√Ωvoj√°≈ôi (a nejen ti) maj√≠ pro pr√°ci s daty rad≈°i vlastn√≠ dom√©novƒõ
		specifick√° rozhran√≠ ne≈æ generick√° rozhran√≠ extern√≠ch knihoven. A maj√≠ pravdu.
		N√°sleduj√≠c√≠ k√≥d je pro ƒçten√°≈ôe mnohem stravitelnƒõj≈°√≠:
	</p>

	<pre>Product product = evitaSession.query(...);
assertEquals("Vidliƒçka na chobotnici", product.getName());
assertEquals("Steelworks", product.getBrand().getName());
assertEquals("345.50", product.getVipPrice().toString());
</pre>

	<p>
		... ne≈æ tento:
	</p>

	<pre>Product product = evitaSession.query(...);
assertEquals("Vidliƒçka na chobotnici", product.getAttribute("name"));
assertEquals("Steelworks", product.getReference("brand").getReferencedEntity().getAttribute("name"));
assertEquals("345.50", product.getPrice("vip").toString());
	</pre>

	<p>
		Proto m√° Java klient (tato funkcionalita nem√° bohu≈æel prozat√≠m ekvivalent v klientech pro
		evitaDB na ostatn√≠ch platform√°ch) zabudovanou z√°kladn√≠ podporu pro interakci s
		aplikaƒçn√≠m k√≥dem v podobƒõ rozhran√≠, kter√° jsou dodan√° a popsan√° v√Ωvoj√°≈ôem.
	</p>

	<p>
		Pojƒème si uk√°zat rozhran√≠, kter√© popisuje podobn√© sch√©ma, jako v p≈ôedchoz√≠
		kapitole:
	</p>

	<pre>@Entity(
    name = "Product",
    description = "A product in inventory."
)
public interface Product {

    @Attribute(
            name = "name",
            description = "Name of the product.",
            localized = true,
            filterable = true,
            sortable = true
    )
    @Nonnull
    String getName();

    @Attribute(
            name = "cores",
            description = "Number of CPU cores.",
            filterable = true
    )
    @Nonnull
    Integer getCores();

    @Attribute(
            name = "graphics",
            description = "Graphics card.",
            filterable = true
    )
    @Nonnull
    String getGraphics();

    @Nonnull
    PriceContract getPriceForSale();

    @Reference(
            name = "brand",
            description = "Brand of the product.",
            entity = Brand.ENTITY_NAME,
            allowEmpty = false,
            indexed = true
    )
    @Nonnull
    Brand getBrand();

    @Reference(
            name = "categories",
            description = "Categories the product belongs to.",
            entity = Category.ENTITY_NAME,
            indexed = true
    )
    @Nonnull
    List&lt;Category> getCategories();

}
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract">https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract</a>
		</em>
	</p>

	<p>
		Deklarace t≈ô√≠dy je zkr√°cena a okoln√≠ t≈ô√≠dy jsou vynech√°ny √∫plnƒõ, ale m≈Ø≈æete si
		je snadno dohledat v na≈°em uk√°zkov√©m repozit√°≈ôi. Jakmile m√°me p≈ôipraven√Ω
		dom√©nov√Ω model, m≈Ø≈æeme podle nƒõj vytvo≈ôit sch√©ma v katalogu datab√°ze:
	</p>

	<pre>evita.updateCatalog(
        "evita-tutorial",
        session -> {
            session.defineEntitySchemaFromModelClass(Brand.class);
            session.defineEntitySchemaFromModelClass(Category.class);
            session.defineEntitySchemaFromModelClass(Product.class);
        }
);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract">https://github.com/FgForrest/evitaDB-tutorial/tree/01.05-define-schema-by-java-contract</a>
		</em>
	</p>

	<p>
		Ve chv√≠li, kdy kdy m√°me vytvo≈ôen√© sch√©ma, m≈Ø≈æeme ta stejn√° rozhran√≠ pou≈æ√≠t i pro
		p≈ô√≠stup k dat≈Øm v nƒõm (a to jak pro z√°pis, tak i pro ƒçten√≠). Implementace m≈Ø≈æete
		samoz≈ôejmƒõ dodat vlastn√≠m aplikaƒçn√≠m k√≥dem, nebo je um√≠ dynamicky generovat
		p≈ô√≠mo evitaDB. Pomoc√≠ knihoven <a href="https://bytebuddy.net/">ByteBuddy</a> a
		<a href="https://github.com/FgForrest/Proxycian">Proxycian</a> vytvo≈ô√≠
		automaticky generovan√© proxy t≈ô√≠dy implementuj√≠c√≠ kontrakt entit. Tyto t≈ô√≠dy
		nebudou tak rychl√© jako ruƒçnƒõ psan√© implementace, ale tento p≈ô√≠stup n√°m u≈°et≈ô√≠
		spoustu ruƒçn√≠ pr√°ce.
	</p>

	<p>
		Pojƒème si tedy uk√°zat, jak s pou≈æit√≠m dom√©novƒõ specifick√Ωch rozhran√≠ vytvo≈ô√≠me
		novou entitu v katalogu:
	</p>

	<pre>final int productId = evita.updateCatalog(
        "evita-tutorial",
        session -> {
            // zalo≈æ√≠me novou znaƒçku skrze na≈°e vlastn√≠ z√°pisov√© rozhran√≠
            final EntityReference appleBrandRef = session.createNewEntity(BrandEditor.class)
                    .setName("Apple", Locale.ENGLISH)
                    .upsertVia(session);

            // zalo≈æ√≠me novou kategorii skrze na≈°e vlastn√≠ z√°pisov√© rozhran√≠
            final EntityReference cellPhonesRef = session.createNewEntity(CategoryEditor.class)
                    .setName("Cell phones", Locale.ENGLISH)
                    .upsertVia(session);

            // a na z√°vƒõr zalo≈æ√≠me produkt, kter√Ω se bude na v√Ω≈°e vytvo≈ôenou
            // znaƒçku a kategorii odkazovat
            final EntityReference productRef = session.createNewEntity(ProductEditor.class)
                    .setName("iPhone 12", Locale.ENGLISH)
                    .setCores(6)
                    .setGraphics("A14 Bionic")
                    .setBrandId(appleBrandRef.getPrimaryKey())
                    .addCategoryId(cellPhonesRef.getPrimaryKey())
                    .upsertVia(session);
        }

        return productRef.getPrimaryKey();

);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces">https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces</a>
		</em>
	</p>

	<p>
		Zalo≈æen√Ω produkt si m≈Ø≈æeme na jin√©m m√≠stƒõ pomoc√≠ na≈°ich vlastn√≠ch rozhran√≠
		naƒç√≠st a vypsat do konzole:
	</p>

	<pre>evita.queryCatalog(
        "evita-tutorial",
        session -> {
            // naƒçteme si produkt podle prim√°rn√≠ho kl√≠ƒçe
            final Product product = session.queryOne(
                            query(
                                    filterBy(
                                            entityPrimaryKeyInSet(productId),
                                            entityLocaleEquals(Locale.ENGLISH)
                                    ),
                                    require(
                                            // ≈ôekneme si o tƒõlo produktu
                                            entityFetch(
                                                    attributeContentAll(),
                                                    // a tak√© tƒõlo odkazovan√© znaƒçky
                                                    referenceContent(
                                                            Product.REFERENCE_BRAND,
                                                            entityFetch(attributeContentAll())
                                                    ),
                                                    // a tƒõla v≈°ech kategori√≠ produktu
                                                    referenceContent(
                                                            Product.REFERENCE_CATEGORIES,
                                                            entityFetch(attributeContentAll())
                                                    )
                                            )
                                    )

                            ),
                            Product.class
                    )
                    .orElseThrow(
                            () -> new IllegalStateException("Product with id " + productId + " not found.")
                    );

            // a jeho data vyp√≠≈°eme do konzole
            System.out.println("Product name: " + product.getName());
            System.out.println("Product cores: " + product.getCores());
            System.out.println("Product graphics: " + product.getGraphics());
            System.out.println("Product brand: " + product.getBrand().getName());
            System.out.println(
                    "Product categories: " +
                            product.getCategories()
                                    .stream()
                                    .map(Category::getName)
                                    .reduce((a, b) -> a + ", " + b)
                                    .orElse("&lt;none>")
            );
        }
);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces">https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces</a>
		</em>
	</p>

	<p>
		A na z√°vƒõr si uk√°≈æeme, jak tento produkt upravit a zmƒõny ulo≈æit zpƒõt do
		datab√°ze.
	</p>

	<pre>evita.updateCatalog(
        "evita-tutorial",
        session -> {
            // produkt si z√≠sk√°me stejnƒõ jako p≈ôi bƒõ≈æn√©m ƒçten√≠
            session.getEntity(
                            Product.class, productId, entityFetchAllContent()
                    )
                    .orElseThrow()
                    // a vytvo≈ô√≠me si jeho novou oddƒõlenou "z√°pisovou" instanci
                    .openForWrite()
                    // uprav√≠me pot≈ôebn√° data
                    .setName("iPhone 12 Pro", Locale.ENGLISH)
                    .setCores(8)
                    // a zmƒõny zap√≠≈°eme zpƒõt na datab√°zov√Ω server
                    .upsertVia(session);
        }
);
	</pre>

	<p>
		<em>Kompletn√≠ p≈ô√≠klad: <a
				href="https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces">https://github.com/FgForrest/evitaDB-tutorial/tree/01.06-write-and-read-data-using-custom-interfaces</a>
		</em>
	</p>

	<p>
		Na p≈ô√≠kladu je vidƒõt, ≈æe pro ƒçten√≠ a z√°pis m√°me oddƒõlen√° rozhran√≠ (nap≈ô. `Brand`
		a `BrandEditor`). Aƒçkoliv se zd√° tento p≈ô√≠stup komplikovanƒõj≈°√≠ ne≈æ m√≠t v≈°echny
		(tj. z√°pisov√© i ƒçtec√≠) metody na spoleƒçn√©m rozhran√≠, m√° jednu z√°sadn√≠ v√Ωhodu.
		Umo≈æ≈àuje odli≈°it instance modelov√© t≈ô√≠dy na vl√°knovƒõ bezpeƒçnou imutabiln√≠
		instanci, kterou m≈Ø≈æeme bezpeƒçnƒõ udr≈æovat t≈ôeba v lok√°ln√≠ cache a pou≈æ√≠vat ji
		souƒçasnƒõ z v√≠ce vl√°ken, a oddƒõlenou instanci otev≈ôenou pro z√°pis, kter√° u≈æ
		vl√°knovƒõ bezpeƒçn√° nen√≠. Kromƒõ toho jsou obƒõ rozhran√≠ mnohem ƒçitelnƒõj≈°√≠, ne≈æ kdy≈æ
		jsou ƒçtec√≠ a z√°pisov√© metody na jedn√© velk√© hromadƒõ - co≈æ ocen√≠te p≈ôedev≈°√≠m u
		rozs√°hlej≈°√≠ch modelov√Ωch rozhran√≠.
	</p>

	<p>
		Pov≈°imnƒõte si, ≈æe aby automatick√© generov√°n√≠ implementac√≠ fungovalo, je nutn√© k
		Java klientovi p≈ôilinkovat dal≈°√≠ knihovnu:
	</p>

	<pre>&lt;dependency&gt;
   &lt;groupId>one.edee.oss&lt;/groupId&gt;
   &lt;artifactId>proxycian_bytebuddy&lt;/artifactId&gt;
   &lt;version>1.3.10&lt;/version&gt;
&lt;/dependency&gt;
	</pre>

	<p>
		Mo≈ænosti pr√°ce s daty pomoc√≠ vlastn√≠ch rozhran√≠ jsou samoz≈ôejmƒõ mnohem ≈°ir≈°√≠,
		ne≈æ n√°m dovoluje z√°bƒõr tohoto ƒçl√°nku, proto si dovol√≠m ƒçten√°≈ôe odk√°zat na
		detailnƒõj≈°√≠ popis v na≈°√≠ <a
			href="https://evitadb.io/documentation/use/connectors/java?lang=java#custom-contracts">dokumentaci</a>.
		K t√©matu se je≈°tƒõ vr√°t√≠me v nƒõkter√©m z dal≈°√≠ch d√≠l≈Ø seri√°lu.
	</p>

	<h2>Kam se pod√≠v√°me p≈ô√≠≈°tƒõ?</h2>

	<p>
		V p≈ô√≠≈°t√≠m d√≠le si uk√°≈æeme to nejd≈Øle≈æitƒõj≈°√≠ ‚Äì z√°kladn√≠ mo≈ænosti dotazovac√≠ho
		jazyka, na kter√©m si udƒõl√°te p≈ôedstavu, v ƒçem v√°m m≈Ø≈æe b√Ωt evitaDB u≈æiteƒçn√°.
		D√≠ky specializaci na √∫zk√Ω segment katalogov√Ωch ≈ôe≈°en√≠ je jazyk designov√°n od
		zaƒç√°tku tak, aby v√°m umo≈ænil rychle vybudovat z√°klad u≈æivatelsk√©ho rozhran√≠ pro
		v√°≈° e-commerce katalog.
	</p>

	<p>
		Dotazy k ƒçl√°nku m≈Ø≈æete, kromƒõ diskuze zde na Root.cz, pokl√°dat i na na≈°em
		<a href="https://discord.gg/VsNBWxgmSw">Discord serveru</a>.
	</p>

</article>
</body>
</html>
