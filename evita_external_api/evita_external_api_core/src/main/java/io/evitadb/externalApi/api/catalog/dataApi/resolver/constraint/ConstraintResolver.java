/*
 *
 *                         _ _        ____  ____
 *               _____   _(_) |_ __ _|  _ \| __ )
 *              / _ \ \ / / | __/ _` | | | |  _ \
 *             |  __/\ V /| | || (_| | |_| | |_) |
 *              \___| \_/ |_|\__\__,_|____/|____/
 *
 *   Copyright (c) 2023
 *
 *   Licensed under the Business Source License, Version 1.1 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   https://github.com/FgForrest/evitaDB/blob/main/LICENSE
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package io.evitadb.externalApi.api.catalog.dataApi.resolver.constraint;

import io.evitadb.api.query.Constraint;
import io.evitadb.api.query.descriptor.ConstraintCreator.ChildParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintCreator.ClassifierParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintCreator.ParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintCreator.ValueParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintDescriptor;
import io.evitadb.api.query.descriptor.ConstraintDescriptorProvider;
import io.evitadb.api.query.descriptor.ConstraintPropertyType;
import io.evitadb.api.query.descriptor.ConstraintType;
import io.evitadb.api.requestResponse.schema.AssociatedDataSchemaContract;
import io.evitadb.api.requestResponse.schema.AttributeSchemaContract;
import io.evitadb.api.requestResponse.schema.CatalogSchemaContract;
import io.evitadb.api.requestResponse.schema.EntitySchemaContract;
import io.evitadb.api.requestResponse.schema.ReferenceSchemaContract;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.ConstraintProcessingUtils;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.ConstraintValueStructure;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.DataLocator;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.DataLocatorWithReference;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.EntityDataLocator;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.FacetDataLocator;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.GenericDataLocator;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.HierarchyDataLocator;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.ReferenceDataLocator;
import io.evitadb.externalApi.exception.ExternalApiInternalError;
import io.evitadb.externalApi.exception.ExternalApiInvalidUsageException;
import io.evitadb.utils.Assert;
import lombok.RequiredArgsConstructor;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

import static io.evitadb.externalApi.api.ExternalApiNamingConventions.CLASSIFIER_NAMING_CONVENTION;

/**
 * Resolves client JSON argument containing JSON representation of {@link Constraint} tree of specific type
 * generated by some {@code ConstraintSchemaBuilder} into original {@link Constraint}s.
 * <p>
 * It is able to resolve common constraint schema generated by a {@code ConstraintSchemaBuilder}. Implementation just needs to
 * define some metadata to help the resolving.
 * <p>
 * If needed, an implementation can alter the process of resolving altogether.
 *
 * <h3>Resolving process</h3>
 * The resolving process begin with parsing of JSON field key to determine original {@link Constraint} and {@link ConstraintDescriptor}
 * for that constraint is found. After that, constraint creator corresponding to JSON field key is found and
 * from its parameters it is determined how to resolve JSON field value (none, primitive, child, or wrapper object).
 * Using these parameters constraint instantiation arguments are reconstructed from that JSON field value.
 * Finally, original constraint is instantiated using the built instantiation arguments and returned.
 *
 * <h3>Children resolving</h3>
 * Resolving of container children is a bit tricky because JSON objects don't have named constructors or factory methods,
 * and thus constraint names are placed in keys instead of actual objects. Therefore, if constraint expects child (or children)
 * all the possible constraints have to be listed in arbitrary object as unique fields. This is fine in case of one concrete
 * expected child (which is quite rare), but if that child can be any type of constraint, all possible constraints must be
 * wrapped inside another `wrapper container`. This allows for unlimited nesting of any constraint but introduces new difficulty.
 * What happens if in that `wrapper container` a client specifies more than one constraint? Throwing an exception is unintuitive
 * and would end up in too much clutter,
 * instead each such `wrapper container` has to be resolved to some `default` constraint container which takes array
 * of children. Each inner constraint is then put as one child into that container. One exception is when container
 * expects that its children are unique to each other, then no `default` constraint container is needed, inner constraints
 * are simply put as array directly into the parent container.
 *
 * <h3>Constraint key formats</h3>
 * Key can have one of 3 formats depending on descriptor data:
 * <ul>
 *     <li>`{fullName}` - if it's generic constraint without classifier</li>
 *     <li>`{propertyType}_{fullName}` - if it's not generic constraint and doesn't have classifier</li>
 *     <li>`{propertyType}_{classifier}_{fullName}` - if it's not generic constraint and has classifier</li>
 * </ul>
 *
 * @author Lukáš Hornych, FG Forrest a.s. (c) 2022
 */
@RequiredArgsConstructor
public abstract class ConstraintResolver<C extends Constraint<?>> {

	@Nonnull
	protected CatalogSchemaContract catalogSchema;

	/**
	 * Resolves single JSON field representing single {@link Constraint}. If constraint is container, child constraints
	 * are recursively resolved as well, ultimately returning a whole tree of constraints.
	 *
	 * @param key key describing constraint generated by {@code ConstraintSchemaBuilder#buildConstraintKey(ConstraintDescriptor, Supplier)}
	 * @param value value containing data for constraint reconstruction
	 * @return resolved constraint with its possible children
	 */
	@Nullable
	public C resolve(@Nonnull String key, @Nullable Object value) {
		return resolve(
			new ResolveContext(getRootDataLocator()),
			key,
			value
		);
	}

	/**
	 * Target output constraint class.
	 */
	protected abstract Class<C> getConstraintClass();

	/**
	 * Defines which type of constraints will be considered when finding which constraint to build schema from.
	 */
	@Nonnull
	protected abstract ConstraintType getConstraintType();

	/**
	 * Wrapper container is used for arbitrary JSON objects which are needed to be able to parse list of different
	 * inner constraints.
	 */
	@Nonnull
	protected abstract ConstraintDescriptor getWrapperContainer();

	/**
	 * Returns root data locator which begins the schema building.
	 */
	@Nonnull
	protected abstract DataLocator getRootDataLocator();

	/**
	 * Returns root query container from which other nested constraints will be built.
	 */
	@Nonnull
	protected abstract ConstraintDescriptor getRootConstraintContainerDescriptor();

	/**
	 * Determines if children constraints are unique.
	 */
	protected boolean isChildrenUnique(@Nonnull ChildParameterDescriptor childParameter) {
		return childParameter.uniqueChildren();
	}

	/**
	 * Resolves single JSON field representing single {@link Constraint}. If constraint is container, child constraints
	 * are recursively resolved as well, ultimately returning a whole tree of constraints.
	 *
	 * @param key key describing constraint generated by {@code ConstraintSchemaBuilder#buildConstraintKey(ConstraintDescriptor, Supplier)}
	 * @param value value containing data for constraint reconstruction
	 * @return resolved constraint with its possible children
	 */
	@Nullable
	protected C resolve(@Nonnull ResolveContext resolveContext, @Nonnull String key, @Nullable Object value) {
		final ParsedKey parsedKey = parseKey(key);
		final ConstraintDescriptor constraintDescriptor = findConstraintDescriptor(parsedKey);
		return reconstructConstraint(resolveContext, parsedKey, constraintDescriptor, value);
	}

	/**
	 * Extracts information from to string key to be able to find original constraint.
	 *
	 * <h3>Formats</h3>
	 * Key can have one of 3 formats depending on descriptor data:
	 * <ul>
	 *     <li>`{fullName}` - if it's generic constraint without classifier</li>
	 *     <li>`{propertyType}_{fullName}` - if it's not generic constraint and doesn't have classifier</li>
	 *     <li>`{propertyType}_{classifier}_{fullName}` - if it's not generic constraint and has classifier</li>
	 * </ul>
	 */
	@Nonnull
	private ParsedKey parseKey(@Nonnull String key) {
		final ConstraintPropertyType propertyType;
		final String classifier;
		final String fullName;

		final int indexOfFirstSplit = key.indexOf(ConstraintProcessingUtils.KEY_PARTS_DELIMITER);
		final int indexOfSecondSplit = key.lastIndexOf(ConstraintProcessingUtils.KEY_PARTS_DELIMITER);
		if (indexOfFirstSplit == -1) {
			// we expect name only
			propertyType = ConstraintPropertyType.GENERIC;
			classifier = null;
			fullName = key;
		} else if (indexOfFirstSplit == indexOfSecondSplit) {
			// we expect group and name only
			final String prefix = key.substring(0, indexOfFirstSplit);
			propertyType = ConstraintProcessingUtils.getPropertyTypeByPrefix(prefix)
				.orElseThrow(() -> createQueryResolvingInternalError("Missing constraint property type for prefix `" + prefix + "`."));
			classifier = null;
			fullName = key.substring(indexOfSecondSplit + 1);
		} else {
			// we expect group, classifier and name
			final String prefix = key.substring(0, indexOfFirstSplit);
			propertyType = ConstraintProcessingUtils.getPropertyTypeByPrefix(prefix)
				.orElseThrow(() -> createQueryResolvingInternalError("Missing constraint property type for prefix `" + prefix + "`."));
			classifier = key.substring(indexOfFirstSplit + 1, indexOfSecondSplit);
			fullName = key.substring(indexOfSecondSplit + 1);
		}

		return new ParsedKey(key, propertyType, classifier, fullName);
	}

	/**
	 * Finds descriptor of original constraint represented by client key.
	 */
	@Nonnull
	private ConstraintDescriptor findConstraintDescriptor(@Nonnull ParsedKey parsedKey) {
		return ConstraintDescriptorProvider
			.getConstraint(
				getConstraintType(),
				parsedKey.propertyType(),
				parsedKey.fullName(),
				parsedKey.classifier()
			)
			.orElseThrow(() ->
				createQueryResolvingInternalError("Unknown constraint `" + parsedKey.originalKey() + "`. Check that it has correct property type and name and support for classifier.")
			);
	}

	/**
	 * Tries to reconstruct constraint object from JSON representation.
	 *
	 * @param parsedKey key representing original constraint
	 * @param constraintDescriptor descriptor of found original constraint
	 * @param value value from client to parse to constraint instantiation args
	 * @return reconstructed constraint or null
	 */
	@Nullable
	private C reconstructConstraint(@Nonnull ResolveContext resolveContext,
	                                @Nonnull ParsedKey parsedKey,
	                                @Nonnull ConstraintDescriptor constraintDescriptor,
	                                @Nullable Object value) {
		final List<Object> instantiationArgs = resolveValueToInstantiationArgs(resolveContext, parsedKey, value, constraintDescriptor);
		if (instantiationArgs == null) {
			return null;
		}
		//noinspection unchecked
		return (C) constraintDescriptor.creator().instantiateConstraint(instantiationArgs.toArray(), parsedKey.originalKey());
	}

	@Nullable
	private List<Object> resolveValueToInstantiationArgs(@Nonnull ResolveContext resolveContext,
	                                                     @Nonnull ParsedKey parsedKey,
	                                                     @Nullable Object value,
	                                                     @Nonnull ConstraintDescriptor constraintDescriptor) {
		final ConstraintValueStructure valueStructure = ConstraintProcessingUtils.getValueStructureForConstraintCreator(constraintDescriptor.creator());

		if (valueStructure == ConstraintValueStructure.NONE) {
			return resolveNoneParameter(parsedKey, value) ? new ArrayList<>(0) : null;
		}

		final List<Object> instantiationArgs = new LinkedList<>();
		final List<ParameterDescriptor> parameters = constraintDescriptor.creator().parameters();
		String originalClassifier = null;
		for (ParameterDescriptor parameter : parameters) {
			if (parameter instanceof ClassifierParameterDescriptor) {
				originalClassifier = resolveClassifierParameter(resolveContext, parsedKey, constraintDescriptor);
				instantiationArgs.add(originalClassifier);
			} else if (parameter instanceof final ValueParameterDescriptor valueParameterDescriptor) {
				instantiationArgs.add(
					resolveValueParameter(valueParameterDescriptor, valueStructure, parsedKey, value)
				);
			} else if (parameter instanceof final ChildParameterDescriptor childParameterDescriptor) {
				instantiationArgs.add(
					resolveChildParameter(resolveContext, constraintDescriptor, childParameterDescriptor, valueStructure, originalClassifier, parsedKey, value)
				);
			}
		}

		return instantiationArgs;
	}

	protected boolean resolveNoneParameter(@Nonnull ParsedKey parsedKey,
	                                       @Nullable Object value) {
		Assert.notNull(
			value,
			() -> createInvalidArgumentException("Constraint `" + parsedKey.originalKey() + "` requires non-null value.")
		);

		return (boolean) value;
	}

	/**
	 * Tries to resolve {@link ClassifierParameterDescriptor} to single constraint instantiation arg.
	 */
	@Nonnull
	private String resolveClassifierParameter(@Nonnull ResolveContext resolveContext,
	                                          @Nonnull ParsedKey parsedKey,
	                                          @Nonnull ConstraintDescriptor constraintDescriptor) {
		final String classifier = parsedKey.classifier();
		Assert.isPremiseValid(
			classifier != null,
			() -> createQueryResolvingInternalError(
				"Constraint `" + parsedKey.originalKey() + "` requires classifier but no classifier found."
			)
		);

		final DataLocator dataLocator = resolveContext.dataLocator();
		final EntitySchemaContract schemaForClassifier = findRequiredEntitySchema(dataLocator);
		return switch (dataLocator.targetDomain()) {
			case ENTITY, GENERIC -> switch (constraintDescriptor.propertyType()) {
				case ATTRIBUTE -> schemaForClassifier.getAttributeByName(classifier, CLASSIFIER_NAMING_CONVENTION)
					.map(AttributeSchemaContract::getName)
					.orElseThrow(() -> createQueryResolvingInternalError(
						"Could not find attribute schema for classifier `" + classifier + "`."
					));
				case ASSOCIATED_DATA -> schemaForClassifier.getAssociatedDataByName(classifier, CLASSIFIER_NAMING_CONVENTION)
					.map(AssociatedDataSchemaContract::getName)
					.orElseThrow(() -> createQueryResolvingInternalError(
						"Could not find associated data schema for classifier `" + classifier + "`."
					));
				case REFERENCE -> schemaForClassifier.getReferenceByName(classifier, CLASSIFIER_NAMING_CONVENTION)
					.map(ReferenceSchemaContract::getName)
					.orElseThrow(() -> createQueryResolvingInternalError(
						"Could not find reference schema for classifier `" + classifier + "`."
					));
				case HIERARCHY -> schemaForClassifier.getReferenceByName(classifier, CLASSIFIER_NAMING_CONVENTION)
					.map(ReferenceSchemaContract::getName)
					.orElseThrow(() -> createQueryResolvingInternalError(
						"Could not find hierarchical reference schema for classifier `" + classifier + "`."
					));
				case FACET -> schemaForClassifier.getReferenceByName(classifier, CLASSIFIER_NAMING_CONVENTION)
					.map(ReferenceSchemaContract::getName)
					.orElseThrow(() -> createQueryResolvingInternalError(
						"Could not find faceted reference schema for classifier `" + classifier + "`."
					));
				default -> throw createQueryResolvingInternalError(
					"Constraint property type `" + constraintDescriptor.propertyType() + "` does not support classifier parameter."
				);
			};
			case REFERENCE, HIERARCHY -> {
				final String referenceName;
				if (dataLocator instanceof final ReferenceDataLocator referenceDataLocator) {
					referenceName = referenceDataLocator.referenceName();
				} else if (dataLocator instanceof final HierarchyDataLocator hierarchyDataLocator) {
					referenceName = hierarchyDataLocator.referenceName();
					Assert.isPremiseValid(
						referenceName != null,
						() -> createQueryResolvingInternalError(
							"Missing reference name for constraint `" + parsedKey.originalKey() + "`."
						)
					);
				} else {
					throw createQueryResolvingInternalError(
						"Illegal data locator type `" + dataLocator.getClass().getName() + "` for domain `" + dataLocator.targetDomain()
					);
				}
				if (constraintDescriptor.propertyType() == ConstraintPropertyType.ATTRIBUTE) {
					yield schemaForClassifier.getReference(referenceName)
						.flatMap(it -> it.getAttributeByName(classifier, CLASSIFIER_NAMING_CONVENTION))
						.map(AttributeSchemaContract::getName)
						.orElseThrow(() -> createQueryResolvingInternalError(
							"Could not find attribute schema for classifier `" + classifier + "`."
						));
				} else {
					throw createQueryResolvingInternalError(
						"Constraint property type `" + constraintDescriptor.propertyType() + "` does not support classifier parameter."
					);
				}
			}
			default -> {
				throw createQueryResolvingInternalError(
					"Classifier parameters are not supported in domain `" + dataLocator.targetDomain() + "`."
				);
			}
		};
	}

	/**
	 * Tries to resolve {@link ValueParameterDescriptor} to single constraint instantiation arg.
	 *
	 * @param parameterDescriptor descriptor of value parameter to resolve
	 * @param constraintValueStructure structure of input value to parse
	 * @param parsedKey key representing original constraint
	 * @param value client value to parse arg from
	 * @return instantiation arg if possible
	 */
	@Nullable
	private Object resolveValueParameter(@Nonnull ValueParameterDescriptor parameterDescriptor,
	                                     @Nonnull ConstraintValueStructure constraintValueStructure,
	                                     @Nonnull ParsedKey parsedKey,
	                                     @Nullable Object value) {
		final Object argument = extractValueParameterFromValue(
			parsedKey,
			value,
			parameterDescriptor,
			constraintValueStructure
		);
		return convertValueParameterArgumentToInstantiationArg(argument, parsedKey, parameterDescriptor);
	}

	/**
	 * Tries to extract raw argument for value descriptor from client value
	 */
	@Nullable
	private Object extractValueParameterFromValue(@Nonnull ParsedKey parsedKey,
	                                         @Nullable Object value,
	                                         @Nonnull ValueParameterDescriptor parameterDescriptor,
	                                         @Nonnull ConstraintValueStructure constraintValueStructure) {
		Object argument;
		final String parameterName = parameterDescriptor.name();

		if (constraintValueStructure == ConstraintValueStructure.WRAPPER_OBJECT) {
			argument = extractValueArgumentFromWrapperObject(parsedKey, value, parameterDescriptor);

			// we want treat missing arrays as empty arrays for more client convenience
			if (argument == null && parameterDescriptor.type().isArray()) {
				//noinspection unchecked
				argument = (Object) createEmptyListObject();
			}

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedKey.originalKey() + "` requires parameter `" + parameterName + "` to be non-null."
				);
			}
		} else if (constraintValueStructure == ConstraintValueStructure.WRAPPER_RANGE) {
			if (parameterName.equals(ConstraintProcessingUtils.WRAPPER_RANGE_FROM_VALUE_PARAMETER)) {
				argument = extractFromArgumentFromWrapperRange(parsedKey, value);

				if (parameterDescriptor.required() && argument == null) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedKey.originalKey() + "` requires `" + ConstraintProcessingUtils.WRAPPER_RANGE_FROM_VALUE_PARAMETER + "` argument of range to be non-null value."
					);
				}
			} else if (parameterName.equals(ConstraintProcessingUtils.WRAPPER_RANGE_TO_VALUE_PARAMETER)) {
				argument = extractToArgumentFromWrapperRange(parsedKey, value);

				if (parameterDescriptor.required() && argument == null) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedKey.originalKey() + "` requires `" + ConstraintProcessingUtils.WRAPPER_RANGE_TO_VALUE_PARAMETER + "` argument of range to be non-null value."
					);
				}
			} else {
				throw createQueryResolvingInternalError("Constraint descriptor for `" + parsedKey.originalKey() + "` has unknown parameter `" + parameterName);
			}
		} else if (constraintValueStructure == ConstraintValueStructure.PRIMITIVE) {
			argument = value;

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedKey.originalKey() + "` requires non-null value."
				);
			}
		} else {
			throw createInvalidArgumentException(
				"Constraint `" + parsedKey.originalKey() + "` requires value parameter but value isn't object, primitive or range value."
			);
		}
		return argument;
	}

	/**
	 * Should extract raw argument from wrapper object `value`.
	 */
	@Nullable
	protected Object extractValueArgumentFromWrapperObject(@Nonnull ParsedKey parsedKey,
	                                                       @Nullable Object value,
	                                                       @Nonnull ValueParameterDescriptor parameterDescriptor) {
		return extractArgumentFromWrapperObject(parsedKey, value, parameterDescriptor.name());
	}

	/**
	 * Should extract raw `from` argument from wrapper range `value`.
	 */
	@Nullable
	protected Object extractFromArgumentFromWrapperRange(@Nonnull ParsedKey parsedKey, @Nullable Object value) {
		return extractRangeFromWrapperRange(parsedKey, value).get(0);
	}

	/**
	 * Should extract raw `to` argument from wrapper range `value`.
	 */
	@Nullable
	protected Object extractToArgumentFromWrapperRange(@Nonnull ParsedKey parsedKey, @Nullable Object value) {
		return extractRangeFromWrapperRange(parsedKey, value).get(1);
	}

	@Nullable
	private Object extractArgumentFromWrapperObject(@Nonnull ParsedKey parsedKey,
	                                                @Nullable Object value,
	                                                @Nonnull String parameterName) {
		final Map<String, Object> wrapperObject;
		try {
			//noinspection unchecked
			wrapperObject = (Map<String, Object>) value;
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedKey + "` expected to be wrapper object but found `" + value + "`."
			);
		}
		if (wrapperObject == null) {
			return null;
		} else {
			return wrapperObject.get(parameterName);
		}
	}

	@Nonnull
	private List<Object> extractRangeFromWrapperRange(@Nonnull ParsedKey parsedKey,
	                                                  @Nullable Object value) {
		final List<Object> range;
		try {
			//noinspection unchecked
			range = (List<Object>) value;
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedKey + "` expected to be wrapper range but found `" + value + "`."
			);
		}
		Assert.notNull(
			range,
			() -> createInvalidArgumentException("Constraint `" + parsedKey.originalKey() + "` requires range value.")
		);
		Assert.isTrue(
			range.size() == ConstraintProcessingUtils.WRAPPER_RANGE_PARAMETERS_COUNT,
			() -> createInvalidArgumentException("Constraint `" + parsedKey.originalKey() + "` has invalid range format.")
		);

		return range;
	}

	/**
	 * Converts extracted raw value parameter argument to target data type needed by value parameter descriptor.
	 */
	@Nullable
	protected Object convertValueParameterArgumentToInstantiationArg(@Nullable Object argument,
	                                                                 @Nonnull ParsedKey parsedKey,
	                                                                 @Nonnull ValueParameterDescriptor valueParameterDescriptor) {
		if (argument == null) {
			// we can return null if parameter isn't required
			return null;
		} else if (valueParameterDescriptor.type().isArray()) {
			final List<Object> listArgument;
			try {
				//noinspection unchecked
				listArgument = (List<Object>) argument;
			} catch (ClassCastException e) {
				throw createQueryResolvingInternalError("Constraint `" + parsedKey.originalKey() + "` expected list value but found `" + argument + "`.");
			}
			//noinspection unchecked
			return convertApiListToSpecificArray(
				(Class<? extends Serializable>) valueParameterDescriptor.type().getComponentType(),
				listArgument
			);
		} else {
			return argument;
		}
	}

	/**
	 * Tries to resolve {@link ChildParameterDescriptor} to single constraint instantiation arg.
	 *
	 * @param resolveContext context for resolving
	 * @param constraintDescriptor descriptor of constraint being resolved
	 * @param parameterDescriptor descriptor of children parameter to resolve
	 * @param constraintValueStructure structure of input value to parse
	 * @param originalClassifier classifier converted to original Evita one
	 * @param parsedKey key representing original constraint
	 * @param value client value to parse arg from
	 * @return instantiation arg if possible
	 */
	@Nullable
	private Object resolveChildParameter(@Nonnull ResolveContext resolveContext,
	                                     @Nonnull ConstraintDescriptor constraintDescriptor,
	                                     @Nonnull ChildParameterDescriptor parameterDescriptor,
	                                     @Nonnull ConstraintValueStructure constraintValueStructure,
	                                     @Nullable String originalClassifier,
	                                     @Nonnull ParsedKey parsedKey,
	                                     @Nullable Object value) {
		final Object argument = extractChildParameterFromValue(
			parsedKey,
			value,
			constraintValueStructure,
			parameterDescriptor
		);

		final ResolveContext childResolveContext = resolveChildrenContext(resolveContext, constraintDescriptor, originalClassifier, parsedKey);
		return convertChildParameterArgumentToInstantiationArg(childResolveContext, argument, parsedKey, parameterDescriptor);
	}

	/**
	 * Tries to extract raw argument for children descriptor from client value
	 */
	@Nullable
	private Object extractChildParameterFromValue(@Nonnull ParsedKey parsedKey,
                                                  @Nullable Object value,
                                                  @Nonnull ConstraintValueStructure constraintValueStructure,
                                                  @Nonnull ChildParameterDescriptor parameterDescriptor) {
		Object argument;
		if (constraintValueStructure == ConstraintValueStructure.WRAPPER_OBJECT) {
			argument = extractChildArgumentFromWrapperObject(parsedKey, value, parameterDescriptor);
			// we want treat missing arrays as empty arrays for more client convenience
			if (argument == null && parameterDescriptor.type().isArray()) {
				//noinspection unchecked
				argument = (Object) (parameterDescriptor.uniqueChildren() ? createEmptyWrapperObject() : createEmptyListObject());
			}

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedKey.originalKey() + "` requires parameter `" + parameterDescriptor.name() + "` to be non-null."
				);
			}
		} else if (constraintValueStructure == ConstraintValueStructure.CHILD) {
			argument = value;

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedKey.originalKey() + "` requires non-null children."
				);
			}
		} else {
			throw createInvalidArgumentException(
				"Constraint `" + parsedKey.originalKey() + "` requires child parameter but value isn't object nor child."
			);
		}
		return argument;
	}

	/**
	 * Should extract raw children argument from wrapper object `value`.
	 */
	@Nullable
	protected Object extractChildArgumentFromWrapperObject(@Nonnull ParsedKey parsedKey,
                                                           @Nullable Object value,
                                                           @Nonnull ChildParameterDescriptor parameterDescriptor) {
		return extractArgumentFromWrapperObject(parsedKey, value, parameterDescriptor.name());
	}

	/**
	 * Converts extracted raw children parameter argument (children constraints) to target data type and structure
	 * needed by children parameter descriptor.
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	private Object convertChildParameterArgumentToInstantiationArg(@Nonnull ResolveContext resolveContext,
	                                                               @Nullable Object argument,
	                                                               @Nonnull ParsedKey parsedKey,
	                                                               @Nonnull ChildParameterDescriptor parameterDescriptor) {
		if (argument == null) {
			// we can return null if parameter isn't required
			return null;
		} else if (parameterDescriptor.type().isArray()) {
			if (argument instanceof Boolean) {
				// child containers doesn't have any usable children, therefore placeholder value is used
				return convertConstraintStreamToSpecificArray((Class<C>) parameterDescriptor.type().getComponentType(), Stream.of());
			}

			if (isChildrenUnique(parameterDescriptor)) {
				// if unique children are needed single wrapping container is expected from client, listing unique constraints
				// inside. But in a constraint constructor, we expect array of concrete unique child constraints without
				// any wrapping container, thus we need to extract child constraints from the wrapping container
				return convertConstraintStreamToSpecificArray(
					(Class<C>) parameterDescriptor.type().getComponentType(),
					resolveContainerInnerConstraints(resolveContext, parsedKey, argument)
				);
			} else {
				final List<Object> children = convertInputListToJavaList(argument, parsedKey);
				return convertConstraintStreamToSpecificArray(
					(Class<C>) parameterDescriptor.type().getComponentType(),
					children.stream()
						// there is additional wrapper object to be able to handle all constraints inside the container,
						// but this object is implicit "and" container, therefore we need to resolve it manually to "and"
						// constraint
						.map(ch -> resolveWrapperContainer(resolveContext, parsedKey, ch))
				);
			}
		} else {
			if (argument instanceof Boolean) {
				// child container doesn't have any usable children, therefore placeholder value is used
				Assert.isPremiseValid(
					!parameterDescriptor.required(),
					"There is require child constraint parameter but only placeholder value came."
				);
				return null;
			}

			// single expected constraint will always be wrapped into default container to be able to define any
			// constraint due to the limitation of JSON objects (they don't have named constructors or factory methods)
			if (isChildrenUnique(parameterDescriptor)) {
				// if unique children are needed we can't return wrapping container because single concrete container is
				// expected in constructor args. We need to extract the container from the wrapping container.
				final List<C> children = resolveContainerInnerConstraints(resolveContext, parsedKey, argument).toList();
				if (children.isEmpty() && parameterDescriptor.required()) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedKey.originalKey() + "` requires parameter `" + parameterDescriptor.name() + "` to be non-empty."
					);
				}
				if (children.size() > 1) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedKey.originalKey() + "` support only one child but there were multiple specified."
					);
				}

				return !children.isEmpty() ? children.get(0) : null;
			} else {
				return resolveWrapperContainer(resolveContext, parsedKey, argument);
			}
		}
	}

	/**
	 * Creates empty wrapper object
	 */
	@Nonnull
	protected Object createEmptyWrapperObject() {
		return Map.of();
	}

	/**
	 * Creates empty list object (object representing list)
	 */
	@Nonnull
	protected Object createEmptyListObject() {
		return List.of();
	}

	/**
	 * Resolves constraint container represented by JSON object and containing inner child constraints
	 * to the {@link #getWrapperContainer()} wrapping constraint container.
	 */
	@Nonnull
	private C resolveWrapperContainer(@Nonnull ResolveContext resolveContext, @Nonnull ParsedKey parsedKey, @Nonnull Object value) {
		final C[] innerConstraints = convertConstraintStreamToSpecificArray(
			getConstraintClass(),
			resolveContainerInnerConstraints(resolveContext, parsedKey, value)
		);
		// expects that default container has constructor with only array of children
		//noinspection unchecked
		return (C) getWrapperContainer().creator().instantiateConstraint(new Object[] { innerConstraints }, parsedKey.originalKey());
	}

	/**
	 * Tries to extract child constraints from constraint container represented by JSON object
	 */
	@Nonnull
	protected Stream<C> resolveContainerInnerConstraints(@Nonnull ResolveContext resolveContext,
	                                                     @Nonnull ParsedKey parsedKey,
	                                                     @Nonnull Object value) {
		if (!(value instanceof Map<?, ?>)) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedKey.originalKey() + "` expected to has container with nested constraints."
			);
		}

		//noinspection unchecked
		final Map<String, Object> innerConstraints = (Map<String, Object>) value;
		return innerConstraints.entrySet()
			.stream()
			.map(c -> resolve(resolveContext, c.getKey(), c.getValue()))
			.filter(Objects::nonNull);
	}

	@SuppressWarnings("unchecked")
	@Nonnull
	private C[] convertConstraintStreamToSpecificArray(@Nonnull Class<C> componentType,
	                                                   @Nonnull Stream<C> constraintStream) {
		return constraintStream.toArray(size -> (C[]) Array.newInstance(componentType, size));
	}

	/**
	 * Should convert input-specific list to Java-specific lis of inner raw input item.
	 */
	@Nonnull
	protected List<Object> convertInputListToJavaList(@Nonnull Object argument, @Nonnull ParsedKey parsedKey) {
		try {
			//noinspection unchecked
			return (List<Object>) argument;
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedKey.originalKey() + "` expected list value but found `" + argument + "`."
			);
		}
	}

	@Nonnull
	protected Optional<EntitySchemaContract> findEntitySchema(@Nonnull DataLocator dataLocator) {
		return catalogSchema.getEntitySchema(dataLocator.entityType());
	}

	@Nonnull
	protected Optional<EntitySchemaContract> findReferencedEntitySchema(@Nonnull DataLocator dataLocator) {
		return findEntitySchema(dataLocator)
			.flatMap(entitySchema -> {
				final String referenceName;
				if (dataLocator instanceof final DataLocatorWithReference dataLocatorWithReference) {
					referenceName = dataLocatorWithReference.referenceName();
				} else {
					throw createQueryResolvingInternalError("Cannot find referenced entity schema for non-reference data locator.");
				}
				if (referenceName == null) {
					// we do not reference any other collection, thus the main one is used as fall back
					return findEntitySchema(dataLocator);
				}

				return entitySchema.getReference(referenceName)
					.filter(ReferenceSchemaContract::isReferencedEntityTypeManaged)
					.flatMap(referenceSchema -> catalogSchema.getEntitySchema(referenceSchema.getReferencedEntityType()));
			});
	}

	@Nonnull
	private ResolveContext resolveChildrenContext(@Nonnull ResolveContext resolveContext,
	                                              @Nonnull ConstraintDescriptor constraintDescriptor,
	                                              @Nullable String originalClassifier,
	                                              @Nonnull ParsedKey parsedKey) {
		if (constraintDescriptor.constraintClass().equals(getRootConstraintContainerDescriptor().constraintClass())) {
			return new ResolveContext(getRootDataLocator());
		}

		final DataLocator dataLocator = resolveContext.dataLocator();
		final DataLocator childDataLocator = switch (constraintDescriptor.propertyType()) {
			case GENERIC -> dataLocator;
			case ENTITY -> {
				if (dataLocator instanceof EntityDataLocator || dataLocator instanceof GenericDataLocator) {
					yield new EntityDataLocator(dataLocator.entityType());
				} else {
					final EntitySchemaContract referencedEntitySchema = findReferencedEntitySchema(dataLocator)
						.orElseThrow(() -> createQueryResolvingInternalError("Missing entity schema for locator `" + dataLocator + "`."));
					yield new EntityDataLocator(referencedEntitySchema.getName());
				}
			}
			case REFERENCE -> {
				Assert.isPremiseValid(
					originalClassifier != null,
					() -> createQueryResolvingInternalError(
						"Reference constraint with children `" + parsedKey.originalKey() + "`  must have classifier."
					)
				);
				yield new ReferenceDataLocator(dataLocator.entityType(), originalClassifier);
			}
			case HIERARCHY -> new HierarchyDataLocator(dataLocator.entityType(), originalClassifier);
			case FACET -> new FacetDataLocator(dataLocator.entityType(), originalClassifier);
			default -> new GenericDataLocator(dataLocator.entityType()); // other domains doesn't support children, thus generic domain is used as the default
		};

		return new ResolveContext(childDataLocator);
	}

	@Nonnull
	protected EntitySchemaContract findRequiredEntitySchema(@Nonnull DataLocator dataLocator) {
		return findEntitySchema(dataLocator)
			.orElseThrow(() -> createQueryResolvingInternalError("Entity schema `" + dataLocator.entityType() + "` is required."));
	}

	@SuppressWarnings("unchecked")
	@Nonnull
	protected  <V extends Serializable> V[] convertApiListToSpecificArray(@Nonnull Class<V> targetComponentType,
	                                                                      @Nonnull List<Object> graphQLList) {
		try {
			//noinspection SuspiciousToArrayCall
			return graphQLList.toArray(size -> (V[]) Array.newInstance(targetComponentType, size));
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError("Could not cast REST list to array of type `" + targetComponentType.getName() + "`");
		}
	}

	@Nonnull
	protected abstract <T extends ExternalApiInternalError> T createQueryResolvingInternalError(@Nonnull String message);

	@Nonnull
	protected abstract <T extends ExternalApiInvalidUsageException>  T createInvalidArgumentException(@Nonnull String message);

	/**
	 * Local context for constraint resolving. It is passed down the constraint tree. Each node can create new
	 * context for its children if received context from parent is not relevant
	 *
	 * @param dataLocator specifies how to get schemas for resolving data
	 */
	protected record ResolveContext(@Nonnull DataLocator dataLocator) {}

	/**
	 * Parsed client key for finding original constraint descriptor.
	 */
	protected record ParsedKey(@Nonnull String originalKey,
	                         @Nonnull ConstraintPropertyType propertyType,
	                         @Nullable String classifier,
	                         @Nonnull String fullName) {}
}
