/*
 *
 *                         _ _        ____  ____
 *               _____   _(_) |_ __ _|  _ \| __ )
 *              / _ \ \ / / | __/ _` | | | |  _ \
 *             |  __/\ V /| | || (_| | |_| | |_) |
 *              \___| \_/ |_|\__\__,_|____/|____/
 *
 *   Copyright (c) 2023
 *
 *   Licensed under the Business Source License, Version 1.1 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   https://github.com/FgForrest/evitaDB/blob/main/LICENSE
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package io.evitadb.externalApi.api.catalog.dataApi.resolver.constraint;

import io.evitadb.api.query.Constraint;
import io.evitadb.api.query.descriptor.ConstraintCreator.AdditionalChildParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintCreator.ChildParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintCreator.ClassifierParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintCreator.ParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintCreator.ValueParameterDescriptor;
import io.evitadb.api.query.descriptor.ConstraintDescriptor;
import io.evitadb.api.query.descriptor.ConstraintDomain;
import io.evitadb.api.query.descriptor.ConstraintType;
import io.evitadb.api.requestResponse.schema.CatalogSchemaContract;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.ConstraintProcessingUtils;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.ConstraintValueStructure;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.DataLocator;
import io.evitadb.externalApi.api.catalog.dataApi.constraint.DataLocatorResolver;
import io.evitadb.externalApi.api.catalog.dataApi.resolver.constraint.ConstraintDescriptorResolver.ParsedConstraintDescriptor;
import io.evitadb.externalApi.exception.ExternalApiInternalError;
import io.evitadb.externalApi.exception.ExternalApiInvalidUsageException;
import io.evitadb.utils.Assert;
import io.evitadb.utils.ClassUtils;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

/**
 * Resolves client JSON argument containing JSON representation of {@link Constraint} tree of specific type
 * generated by some {@code ConstraintSchemaBuilder} into original {@link Constraint}s.
 * <p>
 * It is able to resolve common constraint schema generated by a {@code ConstraintSchemaBuilder}. Implementation just needs to
 * define some metadata to help the resolving.
 * <p>
 * If needed, an implementation can alter the process of resolving altogether.
 *
 * <h3>Resolving process</h3>
 * The resolving process begin with parsing of JSON field key to determine original {@link Constraint} and {@link ConstraintDescriptor}
 * for that constraint is found. After that, constraint creator corresponding to JSON field key is found and
 * from its parameters it is determined how to resolve JSON field value (none, primitive, child, or wrapper object).
 * Using these parameters constraint instantiation arguments are reconstructed from that JSON field value.
 * Finally, original constraint is instantiated using the built instantiation arguments and returned.
 *
 * <h3>Children resolving</h3>
 * Resolving of container children is a bit tricky because JSON objects don't have named constructors or factory methods,
 * and thus constraint names are placed in keys instead of actual objects. Therefore, if constraint expects child (or children)
 * all the possible constraints have to be listed in arbitrary object as unique fields. This is fine in case of one concrete
 * expected child (which is quite rare), but if that child can be any type of constraint, all possible constraints must be
 * wrapped inside another `wrapper container`. This allows for unlimited nesting of any constraint but introduces new difficulty.
 * What happens if in that `wrapper container` a client specifies more than one constraint? Throwing an exception is unintuitive
 * and would end up in too much clutter,
 * instead each such `wrapper container` has to be resolved to some `default` constraint container which takes array
 * of children. Each inner constraint is then put as one child into that container. One exception is when container
 * expects that its children are unique to each other, then no `default` constraint container is needed, inner constraints
 * are simply put as array directly into the parent container.
 *
 * <h3>Constraint key formats</h3>
 * Key can have one of 3 formats depending on descriptor data:
 * <ul>
 *     <li>`{fullName}` - if it's generic constraint without classifier</li>
 *     <li>`{propertyType}{fullName}` - if it's not generic constraint and doesn't have classifier</li>
 *     <li>`{propertyType}{classifier}{fullName}` - if it's not generic constraint and has classifier</li>
 * </ul>
 *
 * @author Lukáš Hornych, FG Forrest a.s. (c) 2022
 */
public abstract class ConstraintResolver<C extends Constraint<?>> {

	@Nonnull protected final CatalogSchemaContract catalogSchema;
	@Nonnull private final ConstraintDescriptorResolver keyParser;
	@Nonnull private final DataLocatorResolver dataLocatorResolver;
	/**
	 * Map of additional resolvers for cross-resolving constraints of different constraint types.
	 */
	@Nonnull private final Map<ConstraintType, AtomicReference<? extends ConstraintResolver<?>>> additionalResolvers;

	public ConstraintResolver(@Nonnull CatalogSchemaContract catalogSchema,
	                          @Nonnull Map<ConstraintType, AtomicReference<? extends ConstraintResolver<?>>> additionalResolvers) {
		Assert.isPremiseValid(
			additionalResolvers.keySet()
				.stream()
				.noneMatch(it -> it.equals(getConstraintType())),
			() -> createQueryResolvingInternalError("Resolver of type `" + getConstraintType() + "` cannot have additional resolver of same type.")
		);

		this.catalogSchema = catalogSchema;
		this.keyParser = new ConstraintDescriptorResolver(catalogSchema, getConstraintType());
		this.dataLocatorResolver = new DataLocatorResolver(catalogSchema);
		this.additionalResolvers = additionalResolvers;
	}

	/**
	 * Resolves single JSON field representing single {@link Constraint}. If constraint is container, child constraints
	 * are recursively resolved as well, ultimately returning a whole tree of constraints.
	 *
	 * @param rootDataLocator defines data context for the root constraint container
	 * @param key key describing constraint generated by {@code ConstraintSchemaBuilder#buildConstraintKey(ConstraintDescriptor, Supplier)}
	 * @param value value containing data for constraint reconstruction
	 * @return resolved constraint with its possible children
	 */
	@Nullable
	public C resolve(@Nonnull DataLocator rootDataLocator, @Nonnull String key, @Nullable Object value) {
		return resolve(
			new ConstraintResolveContext(rootDataLocator),
			key,
			value
		);
	}

	/**
	 * Resolves single JSON field representing single {@link Constraint}. If constraint is container, child constraints
	 * are recursively resolved as well, ultimately returning a whole tree of constraints.
	 *
	 * @param parentDataLocator defines virtual data context of virtual parent constraint that doesn't really exist we
	 *                          want to act like it does (e.g. when the parent constraint is implicit in some context)
	 * @param dataLocator defines data context for the current constraint container
	 * @param key key describing constraint generated by {@code ConstraintSchemaBuilder#buildConstraintKey(ConstraintDescriptor, Supplier)}
	 * @param value value containing data for constraint reconstruction
	 * @return resolved constraint with its possible children
	 */
	@Nullable
	public C resolve(@Nonnull DataLocator parentDataLocator, @Nonnull DataLocator dataLocator, @Nonnull String key, @Nullable Object value) {
		return resolve(
			new ConstraintResolveContext(parentDataLocator, dataLocator),
			key,
			value
		);
	}

	/**
	 * Resolves single JSON field representing single {@link Constraint}. If constraint is container, child constraints
	 * are recursively resolved as well, ultimately returning a whole tree of constraints.
	 *
	 * @param key key describing constraint generated by {@code ConstraintSchemaBuilder#buildConstraintKey(ConstraintDescriptor, Supplier)}
	 * @param value value containing data for constraint reconstruction
	 * @return resolved constraint with its possible children
	 */
	@Nullable
	protected C resolve(@Nonnull ConstraintResolveContext resolveContext, @Nonnull String key, @Nullable Object value) {
		final ParsedConstraintDescriptor parsedConstraintDescriptor = keyParser.resolve(resolveContext, key)
			.orElseThrow(() -> createQueryResolvingInternalError("Unknown constraint `" + key + "`. Check that it has correct property type and name and support for classifier."));
		final ConstraintResolveContext innerResolveContext = resolveContext.switchToChildContext(parsedConstraintDescriptor.innerDataLocator());
		return reconstructConstraint(innerResolveContext, parsedConstraintDescriptor, value);
	}


	/**
	 * Target output constraint class.
	 */
	protected abstract Class<C> getConstraintClass();

	/**
	 * Defines which type of constraints will be considered when finding which constraint to build schema from.
	 */
	@Nonnull
	protected abstract ConstraintType getConstraintType();

	/**
	 * Wrapper container is used for arbitrary JSON objects which are needed to be able to parse list of different
	 * inner constraints.
	 */
	@Nonnull
	protected abstract Optional<ConstraintDescriptor> getWrapperContainer();

	/**
	 * Returns root query container from which other nested constraints will be built.
	 */
	@Nonnull
	protected abstract ConstraintDescriptor getDefaultRootConstraintContainerDescriptor();

	/**
	 * Determines if children constraints are unique.
	 */
	protected boolean isChildrenUnique(@Nonnull ChildParameterDescriptor childParameter) {
		return childParameter.uniqueChildren();
	}

	/**
	 * Tries to reconstruct constraint object from JSON representation.
	 *
	 * @param parsedConstraintDescriptor key representing original constraint
	 * @param value value from client to parse to constraint instantiation args
	 * @return reconstructed constraint or null
	 */
	@Nullable
	private C reconstructConstraint(@Nonnull ConstraintResolveContext resolveContext,
	                                @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                @Nullable Object value) {
		final List<Object> instantiationArgs = resolveValueToInstantiationArgs(resolveContext, parsedConstraintDescriptor, value);
		if (instantiationArgs == null) {
			return null;
		}
		//noinspection unchecked
		return (C) parsedConstraintDescriptor.constraintDescriptor().creator().instantiateConstraint(instantiationArgs.toArray(), parsedConstraintDescriptor.originalKey());
	}

	@Nullable
	private List<Object> resolveValueToInstantiationArgs(@Nonnull ConstraintResolveContext resolveContext,
	                                                     @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                     @Nullable Object value) {
		final ConstraintValueStructure valueStructure = ConstraintProcessingUtils.getValueStructureForConstraintCreator(
			parsedConstraintDescriptor.constraintDescriptor().creator()
		);

		if (valueStructure == ConstraintValueStructure.NONE &&
			!parsedConstraintDescriptor.constraintDescriptor().creator().hasClassifierParameter()) {
			return resolveNoneParameter(parsedConstraintDescriptor, value) ? new ArrayList<>(0) : null;
		}

		final List<Object> instantiationArgs = new LinkedList<>();
		final List<ParameterDescriptor> parameters = parsedConstraintDescriptor.constraintDescriptor().creator().parameters();
		for (ParameterDescriptor parameter : parameters) {
			final Object argument;
			if (parameter instanceof ClassifierParameterDescriptor) {
				argument = resolveClassifierParameter(parsedConstraintDescriptor);
			} else if (parameter instanceof final ValueParameterDescriptor valueParameterDescriptor) {
				argument = resolveValueParameter(valueParameterDescriptor, valueStructure, parsedConstraintDescriptor, value);
			} else if (parameter instanceof final ChildParameterDescriptor childParameterDescriptor) {
				argument = resolveChildParameter(resolveContext, childParameterDescriptor, valueStructure, parsedConstraintDescriptor, value);
			} else if (parameter instanceof final AdditionalChildParameterDescriptor additionalChildParameterDescriptor) {
				argument = resolveAdditionalChildParameter(resolveContext, additionalChildParameterDescriptor, valueStructure, parsedConstraintDescriptor, value);
			} else {
				throw createQueryResolvingInternalError("Unknown parameter type `" + parameter.getClass().getName() + "`.");
			}
			instantiationArgs.add(argument);
		}

		return instantiationArgs;
	}

	private boolean resolveNoneParameter(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                     @Nullable Object value) {
		Assert.notNull(
			value,
			() -> createInvalidArgumentException("Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires non-null value.")
		);

		return (boolean) value;
	}

	/**
	 * Tries to resolve {@link ClassifierParameterDescriptor} to single constraint instantiation arg.
	 */
	@Nonnull
	private String resolveClassifierParameter(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor) {
		final String classifier = parsedConstraintDescriptor.classifier();
		Assert.isPremiseValid(
			classifier != null,
			() -> createQueryResolvingInternalError(
				"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires classifier but no classifier found."
			)
		);
		return classifier;
	}

	/**
	 * Tries to resolve {@link ValueParameterDescriptor} to single constraint instantiation arg.
	 *
	 * @param parameterDescriptor descriptor of value parameter to resolve
	 * @param constraintValueStructure structure of input value to parse
	 * @param parsedConstraintDescriptor key representing original constraint
	 * @param value client value to parse arg from
	 * @return instantiation arg if possible
	 */
	@Nullable
	private Object resolveValueParameter(@Nonnull ValueParameterDescriptor parameterDescriptor,
	                                     @Nonnull ConstraintValueStructure constraintValueStructure,
	                                     @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                     @Nullable Object value) {
		final Object argument = extractValueParameterFromValue(
			parsedConstraintDescriptor,
			value,
			parameterDescriptor,
			constraintValueStructure
		);
		return convertValueParameterArgumentToInstantiationArg(argument, parsedConstraintDescriptor, parameterDescriptor);
	}

	/**
	 * Tries to extract raw argument for value descriptor from client value
	 */
	@Nullable
	private Object extractValueParameterFromValue(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                         @Nullable Object value,
	                                         @Nonnull ValueParameterDescriptor parameterDescriptor,
	                                         @Nonnull ConstraintValueStructure constraintValueStructure) {
		Object argument;
		final String parameterName = parameterDescriptor.name();

		if (constraintValueStructure == ConstraintValueStructure.WRAPPER_OBJECT) {
			argument = extractValueArgumentFromWrapperObject(parsedConstraintDescriptor, value, parameterDescriptor);

			// we want treat missing arrays as empty arrays for more client convenience
			if (argument == null && parameterDescriptor.type().isArray()) {
				argument = createEmptyListObject();
			}

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires parameter `" + parameterName + "` to be non-null."
				);
			}
		} else if (constraintValueStructure == ConstraintValueStructure.WRAPPER_RANGE) {
			if (parameterName.equals(ConstraintProcessingUtils.WRAPPER_RANGE_FROM_VALUE_PARAMETER)) {
				argument = extractFromArgumentFromWrapperRange(parsedConstraintDescriptor, value);

				if (parameterDescriptor.required() && argument == null) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires `" + ConstraintProcessingUtils.WRAPPER_RANGE_FROM_VALUE_PARAMETER + "` argument of range to be non-null value."
					);
				}
			} else if (parameterName.equals(ConstraintProcessingUtils.WRAPPER_RANGE_TO_VALUE_PARAMETER)) {
				argument = extractToArgumentFromWrapperRange(parsedConstraintDescriptor, value);

				if (parameterDescriptor.required() && argument == null) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires `" + ConstraintProcessingUtils.WRAPPER_RANGE_TO_VALUE_PARAMETER + "` argument of range to be non-null value."
					);
				}
			} else {
				throw createQueryResolvingInternalError("Constraint descriptor for `" + parsedConstraintDescriptor.originalKey() + "` has unknown parameter `" + parameterName);
			}
		} else if (constraintValueStructure == ConstraintValueStructure.PRIMITIVE) {
			argument = value;

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires non-null value."
				);
			}
		} else {
			throw createInvalidArgumentException(
				"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires value parameter but value isn't object, primitive or range value."
			);
		}
		return argument;
	}

	/**
	 * Should extract raw argument from wrapper object `value`.
	 */
	@Nullable
	private Object extractValueArgumentFromWrapperObject(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                       @Nullable Object value,
	                                                       @Nonnull ValueParameterDescriptor parameterDescriptor) {
		return extractArgumentFromWrapperObject(parsedConstraintDescriptor, value, parameterDescriptor.name());
	}

	/**
	 * Should extract raw `from` argument from wrapper range `value`.
	 */
	@Nullable
	private Object extractFromArgumentFromWrapperRange(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor, @Nullable Object value) {
		return extractRangeFromWrapperRange(parsedConstraintDescriptor, value).get(0);
	}

	/**
	 * Should extract raw `to` argument from wrapper range `value`.
	 */
	@Nullable
	private Object extractToArgumentFromWrapperRange(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor, @Nullable Object value) {
		return extractRangeFromWrapperRange(parsedConstraintDescriptor, value).get(1);
	}

	@Nullable
	private Object extractArgumentFromWrapperObject(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                @Nullable Object value,
	                                                @Nonnull String parameterName) {
		final Map<String, Object> wrapperObject;
		try {
			//noinspection unchecked
			wrapperObject = (Map<String, Object>) value;
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedConstraintDescriptor + "` expected to be wrapper object but found `" + value + "`."
			);
		}
		if (wrapperObject == null) {
			return null;
		} else {
			return wrapperObject.get(parameterName);
		}
	}

	@Nonnull
	private List<Object> extractRangeFromWrapperRange(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                  @Nullable Object value) {
		final List<Object> range;
		try {
			//noinspection unchecked
			range = (List<Object>) value;
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedConstraintDescriptor + "` expected to be wrapper range but found `" + value + "`."
			);
		}
		Assert.notNull(
			range,
			() -> createInvalidArgumentException("Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires range value.")
		);
		Assert.isTrue(
			range.size() == ConstraintProcessingUtils.WRAPPER_RANGE_PARAMETERS_COUNT,
			() -> createInvalidArgumentException("Constraint `" + parsedConstraintDescriptor.originalKey() + "` has invalid range format.")
		);

		return range;
	}

	/**
	 * Converts extracted raw value parameter argument to target data type needed by value parameter descriptor.
	 */
	@Nullable
	private Object convertValueParameterArgumentToInstantiationArg(@Nullable Object argument,
	                                                               @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                               @Nonnull ValueParameterDescriptor valueParameterDescriptor) {
		if (argument == null) {
			// we can return null if parameter isn't required
			return null;
		} else if (valueParameterDescriptor.type().isArray()) {
			final List<Object> listArgument;
			try {
				//noinspection unchecked
				listArgument = (List<Object>) argument;
			} catch (ClassCastException e) {
				throw createQueryResolvingInternalError("Constraint `" + parsedConstraintDescriptor.originalKey() + "` expected list value but found `" + argument + "`.");
			}
			//noinspection unchecked
			return convertApiListToSpecificArray(
				(Class<? extends Serializable>) valueParameterDescriptor.type().getComponentType(),
				listArgument
			);
		} else {
			return argument;
		}
	}

	/**
	 * Tries to resolve {@link ChildParameterDescriptor} to single constraint instantiation arg.
	 *
	 * @param resolveContext context for resolving
	 * @param childParameterDescriptor descriptor of children parameter to resolve
	 * @param constraintValueStructure structure of input value to parse
	 * @param parsedConstraintDescriptor key representing original constraint
	 * @param value client value to parse arg from
	 * @return instantiation arg if possible
	 */
	@Nullable
	private Object resolveChildParameter(@Nonnull ConstraintResolveContext resolveContext,
	                                     @Nonnull ChildParameterDescriptor childParameterDescriptor,
	                                     @Nonnull ConstraintValueStructure constraintValueStructure,
	                                     @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                     @Nullable Object value) {
		final Object argument = extractChildParameterFromValue(
			parsedConstraintDescriptor,
			value,
			constraintValueStructure,
			childParameterDescriptor
		);

		final DataLocator childDataLocator = resolveChildDataLocator(resolveContext, parsedConstraintDescriptor, childParameterDescriptor.domain());
		final ConstraintResolveContext childResolveContext = resolveContext.switchToChildContext(childDataLocator);
		return convertChildParameterArgumentToInstantiationArg(childResolveContext, argument, parsedConstraintDescriptor, childParameterDescriptor);
	}

	/**
	 * Tries to extract raw argument for children descriptor from client value
	 */
	@Nullable
	private Object extractChildParameterFromValue(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
                                                  @Nullable Object value,
                                                  @Nonnull ConstraintValueStructure constraintValueStructure,
                                                  @Nonnull ChildParameterDescriptor parameterDescriptor) {
		Object argument;
		if (constraintValueStructure == ConstraintValueStructure.WRAPPER_OBJECT) {
			argument = extractChildArgumentFromWrapperObject(parsedConstraintDescriptor, value, parameterDescriptor);
			// we want treat missing arrays as empty arrays for more client convenience
			if (argument == null && parameterDescriptor.type().isArray()) {
				argument = parameterDescriptor.uniqueChildren() ? createEmptyWrapperObject() : createEmptyListObject();
			}

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires parameter `" + parameterDescriptor.name() + "` to be non-null."
				);
			}
		} else if (constraintValueStructure == ConstraintValueStructure.CHILD) {
			argument = value;

			if (parameterDescriptor.required() && argument == null) {
				throw createInvalidArgumentException(
					"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires non-null children."
				);
			}
		} else {
			throw createInvalidArgumentException(
				"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires child parameter but value isn't object nor child."
			);
		}
		return argument;
	}

	/**
	 * Should extract raw children argument from wrapper object `value`.
	 */
	@Nullable
	private Object extractChildArgumentFromWrapperObject(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
                                                         @Nullable Object value,
                                                         @Nonnull ChildParameterDescriptor parameterDescriptor) {
		return extractArgumentFromWrapperObject(parsedConstraintDescriptor, value, parameterDescriptor.name());
	}

	/**
	 * Converts extracted raw children parameter argument (children constraints) to target data type and structure
	 * needed by children parameter descriptor.
	 */
	@SuppressWarnings("unchecked")
	@Nullable
	private Object convertChildParameterArgumentToInstantiationArg(@Nonnull ConstraintResolveContext resolveContext,
	                                                               @Nullable Object argument,
	                                                               @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                               @Nonnull ChildParameterDescriptor parameterDescriptor) {


		if (argument == null) {
			// we can return null if parameter isn't required
			return null;
		}

		// Actual constraint will be resolved as root constraint for proper context switching without wrapper containers.
		final Class<?> childParameterType = parameterDescriptor.type();
		if (!childParameterType.isArray() && !ClassUtils.isAbstract(childParameterType)) {
			return resolve(
				resolveContext,
				parameterDescriptor.name(),
				argument
			);
		}

		if (parameterDescriptor.type().isArray()) {
			if (argument instanceof Boolean) {
				// child containers doesn't have any usable children, therefore placeholder value is used
				return convertConstraintStreamToSpecificArray((Class<C>) parameterDescriptor.type().getComponentType(), Stream.of());
			}

			if (isChildrenUnique(parameterDescriptor)) {
				// if unique children are needed single wrapping container is expected from client, listing unique constraints
				// inside. But in a constraint constructor, we expect array of concrete unique child constraints without
				// any wrapping container, thus we need to extract child constraints from the wrapping container
				return convertConstraintStreamToSpecificArray(
					(Class<C>) parameterDescriptor.type().getComponentType(),
					resolveContainerInnerConstraints(resolveContext, parsedConstraintDescriptor, argument)
				);
			} else {
				final List<Object> children = convertInputListToJavaList(argument, parsedConstraintDescriptor);
				if (getWrapperContainer().isEmpty()) {
					// we want to flatten the wrapper container because there is no equivalent constraint to represent
					// the wrapper container
					return convertConstraintStreamToSpecificArray(
						(Class<C>) parameterDescriptor.type().getComponentType(),
						children.stream()
							.flatMap(ch -> resolveContainerInnerConstraints(resolveContext, parsedConstraintDescriptor, ch))
					);
				} else {
					return convertConstraintStreamToSpecificArray(
						(Class<C>) parameterDescriptor.type().getComponentType(),
						children.stream()
							// there is additional wrapper object to be able to handle all constraints inside the container,
							// but this object is implicit "and" container, therefore we need to resolve it manually to "and"
							// constraint
							.map(ch -> resolveWrapperContainer(resolveContext, parsedConstraintDescriptor, ch))
					);
				}
			}
		} else {
			if (argument instanceof Boolean) {
				// child container doesn't have any usable children, therefore placeholder value is used
				Assert.isPremiseValid(
					!parameterDescriptor.required(),
					"There is require child constraint parameter but only placeholder value came."
				);
				return null;
			}

			// single expected constraint will always be wrapped into default container to be able to define any
			// constraint due to the limitation of JSON objects (they don't have named constructors or factory methods)
			if (isChildrenUnique(parameterDescriptor)) {
				// if unique children are needed we can't return wrapping container because single concrete container is
				// expected in constructor args. We need to extract the container from the wrapping container.
				final List<C> children = resolveContainerInnerConstraints(resolveContext, parsedConstraintDescriptor, argument).toList();
				if (children.isEmpty() && parameterDescriptor.required()) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires parameter `" + parameterDescriptor.name() + "` to be non-empty."
					);
				}
				if (children.size() > 1) {
					throw createInvalidArgumentException(
						"Constraint `" + parsedConstraintDescriptor.originalKey() + "` support only one child but there were multiple specified."
					);
				}

				return !children.isEmpty() ? children.get(0) : null;
			} else {
				Assert.isPremiseValid(
					getWrapperContainer().isPresent(),
					() -> createQueryResolvingInternalError("Child is not array but no wrapper container is configured.")
				);
				return resolveWrapperContainer(resolveContext, parsedConstraintDescriptor, argument);
			}
		}
	}


	/**
	 * Tries to resolve {@link AdditionalChildParameterDescriptor} to single constraint instantiation arg.
	 *
	 * @param resolveContext context for resolving
	 * @param additionalChildParameterDescriptor descriptor of additional child parameter to resolve
	 * @param constraintValueStructure structure of input value to parse
	 * @param parsedConstraintDescriptor key representing original constraint
	 * @param value client value to parse arg from
	 * @return instantiation arg if possible
	 */
	@Nullable
	private Object resolveAdditionalChildParameter(@Nonnull ConstraintResolveContext resolveContext,
	                                               @Nonnull AdditionalChildParameterDescriptor additionalChildParameterDescriptor,
	                                               @Nonnull ConstraintValueStructure constraintValueStructure,
	                                               @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                               @Nullable Object value) {
		final Object argument = extractAdditionalChildParameterFromValue(
			parsedConstraintDescriptor,
			value,
			constraintValueStructure,
			additionalChildParameterDescriptor
		);

		final DataLocator childDataLocator = resolveChildDataLocator(resolveContext, parsedConstraintDescriptor, additionalChildParameterDescriptor.domain());
		final ConstraintResolveContext childResolveContext = resolveContext.switchToChildContext(childDataLocator);
		return convertAdditionalChildParameterArgumentToInstantiationArg(childResolveContext, argument, additionalChildParameterDescriptor);
	}

	/**
	 * Tries to extract raw argument for additional child descriptor from client value
	 */
	@Nullable
	private Object extractAdditionalChildParameterFromValue(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                        @Nullable Object value,
	                                                        @Nonnull ConstraintValueStructure constraintValueStructure,
	                                                        @Nonnull AdditionalChildParameterDescriptor parameterDescriptor) {
		if (constraintValueStructure != ConstraintValueStructure.WRAPPER_OBJECT) {
			throw createInvalidArgumentException(
				"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires additional child parameter but value isn't object."
			);
		}

		final Object argument = extractAdditionalChildArgumentFromWrapperObject(parsedConstraintDescriptor, value, parameterDescriptor);
		if (parameterDescriptor.required() && argument == null) {
			throw createInvalidArgumentException(
				"Constraint `" + parsedConstraintDescriptor.originalKey() + "` requires parameter `" + parameterDescriptor.name() + "` to be non-null."
			);
		}
		return argument;
	}

	/**
	 * Should extract raw children argument from wrapper object `value`.
	 */
	@Nullable
	private Object extractAdditionalChildArgumentFromWrapperObject(@Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                               @Nullable Object value,
	                                                               @Nonnull AdditionalChildParameterDescriptor parameterDescriptor) {
		return extractArgumentFromWrapperObject(parsedConstraintDescriptor, value, parameterDescriptor.name());
	}

	/**
	 * Converts extracted raw additional child parameter argument (children constraints) to target data type and structure
	 * needed by children parameter descriptor.
	 * <b>Note: </b> currently, we assume that the type of child parameter is generic container with only one direct child
	 * parameter. Otherwise, there would have to be logic for another nested implicit container which currently doesn't make
	 * sense.
	 */
	@Nullable
	private Object convertAdditionalChildParameterArgumentToInstantiationArg(@Nonnull ConstraintResolveContext resolveContext,
	                                                                         @Nullable Object argument,
	                                                                         @Nonnull AdditionalChildParameterDescriptor parameterDescriptor) {
		if (argument == null) {
			// we can return null if parameter isn't required
			return null;
		}

		final AtomicReference<? extends ConstraintResolver<?>> resolver = additionalResolvers.get(parameterDescriptor.constraintType());
		Assert.isPremiseValid(
			resolver != null,
			() -> createQueryResolvingInternalError("Missing resolver for constraint type `" + parameterDescriptor.constraintType() + "`.")
		);

		return resolver.get().resolve(resolveContext, parameterDescriptor.name(), argument);
	}

	/**
	 * Creates empty wrapper object
	 */
	@Nonnull
	private Object createEmptyWrapperObject() {
		return Map.of();
	}

	/**
	 * Creates empty list object (object representing list)
	 */
	@Nonnull
	private Object createEmptyListObject() {
		return List.of();
	}

	/**
	 * Resolves constraint container represented by JSON object and containing inner child constraints
	 * to the {@link #getWrapperContainer()} wrapping constraint container.
	 */
	@Nonnull
	private C resolveWrapperContainer(@Nonnull ConstraintResolveContext resolveContext,
	                                  @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                  @Nonnull Object value) {
		final C[] innerConstraints = convertConstraintStreamToSpecificArray(
			getConstraintClass(),
			resolveContainerInnerConstraints(resolveContext, parsedConstraintDescriptor, value)
		);
		// expects that default container has constructor with only array of children
		//noinspection unchecked
		return (C) getWrapperContainer()
			.orElseThrow(() -> createQueryResolvingInternalError("Missing required wrapper container."))
			.creator()
			.instantiateConstraint(new Object[] { innerConstraints }, parsedConstraintDescriptor.originalKey());
	}

	/**
	 * Tries to extract child constraints from constraint container represented by JSON object
	 */
	@Nonnull
	private Stream<C> resolveContainerInnerConstraints(@Nonnull ConstraintResolveContext resolveContext,
	                                                   @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                                   @Nonnull Object value) {
		if (!(value instanceof Map<?, ?>)) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedConstraintDescriptor.originalKey() + "` expected to has container with nested constraints."
			);
		}

		//noinspection unchecked
		final Map<String, Object> innerConstraints = (Map<String, Object>) value;
		return innerConstraints.entrySet()
			.stream()
			.map(c -> resolve(resolveContext, c.getKey(), c.getValue()))
			.filter(Objects::nonNull);
	}

	@SuppressWarnings("unchecked")
	@Nonnull
	private C[] convertConstraintStreamToSpecificArray(@Nonnull Class<C> componentType,
	                                                   @Nonnull Stream<C> constraintStream) {
		return constraintStream.toArray(size -> (C[]) Array.newInstance(componentType, size));
	}

	/**
	 * Should convert input-specific list to Java-specific lis of inner raw input item.
	 */
	@Nonnull
	private List<Object> convertInputListToJavaList(@Nonnull Object argument, @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor) {
		try {
			//noinspection unchecked
			return (List<Object>) argument;
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError(
				"Constraint `" + parsedConstraintDescriptor.originalKey() + "` expected list value but found `" + argument + "`."
			);
		}
	}

	/**
	 * Tries to resolve or switch domain of current constraint to desired domain for child constraints.
	 *
	 * @param resolveContext current context with current domain (data locator)
	 * @param parsedConstraintDescriptor current constraint descriptor
	 * @param desiredChildDomain desired domain for child constraints
	 */
	@Nonnull
	private DataLocator resolveChildDataLocator(@Nonnull ConstraintResolveContext resolveContext,
	                                            @Nonnull ParsedConstraintDescriptor parsedConstraintDescriptor,
	                                            @Nonnull ConstraintDomain desiredChildDomain) {
		final ConstraintDescriptor constraintDescriptor = parsedConstraintDescriptor.constraintDescriptor();
		if (constraintDescriptor.constraintClass().equals(getDefaultRootConstraintContainerDescriptor().constraintClass())) {
			return resolveContext.dataLocator();
		}
		return dataLocatorResolver.resolveChildParameterDataLocator(resolveContext.dataLocator(), desiredChildDomain);
	}

	@SuppressWarnings("unchecked")
	@Nonnull
	private <V extends Serializable> V[] convertApiListToSpecificArray(@Nonnull Class<V> targetComponentType,
	                                                                      @Nonnull List<Object> graphQLList) {
		try {
			//noinspection SuspiciousToArrayCall
			return graphQLList.toArray(size -> (V[]) Array.newInstance(targetComponentType, size));
		} catch (ClassCastException e) {
			throw createQueryResolvingInternalError("Could not cast REST list to array of type `" + targetComponentType.getName() + "`");
		}
	}

	@Nonnull
	protected abstract <T extends ExternalApiInternalError> T createQueryResolvingInternalError(@Nonnull String message);

	@Nonnull
	protected abstract <T extends ExternalApiInvalidUsageException>  T createInvalidArgumentException(@Nonnull String message);

}
