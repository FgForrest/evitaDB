syntax = "proto3";

package io.evitadb.externalApi.grpc.generated;
option java_multiple_files = true;
option csharp_namespace = "EvitaDB";

import "GrpcEvitaDataTypes.proto";
import "GrpcEnums.proto";
import "google/protobuf/wrappers.proto";

// This is the definition object for entity. Definition objects allow to describe the structure
// of the entity type so that in any time everyone can consult complete structure of the entity type.
//
// Based on our experience we've designed following data model for handling entities in evitaDB. Model is rather complex
// but was designed to limit amount of data fetched from database and minimize an amount of data that are indexed and subject
// to search.
//
// Minimal entity definition consists of:
// - entity type and
// - primary key (even this is optional and may be autogenerated by the database).
//
// Other entity data is purely optional and may not be used at all.
message GrpcEntitySchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // Contains version of this entity schema and gets increased with any entity type update. Allows to execute
  // optimistic locking i.e. avoiding parallel modifications.
  int32 version = 2;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 3;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 4;
  // Contains `true` when primary keys of entities of this type will not be provided by the external systems and Evita
  // is responsible for generating unique primary keys for the entity on insertion.
  //
  // Generated key is guaranteed to be unique, but may not represent continuous ascending series. Generated key
  // will be always greater than zero.
  bool withGeneratedPrimaryKey = 5;
  // Contains `true` when entities of this type are organized in a tree like structure (hierarchy) where certain entities
  // are subordinate of other entities.
  //
  // Entities may be organized in hierarchical fashion. That means that entity may refer to single parent entity and may be
  // referred by multiple child entities. Hierarchy is always composed of entities of same type.
  // Each entity must be part of at most single hierarchy (tree).
  //
  // Hierarchy can limit returned entities by using filtering constraints. It's also used for
  // computation of extra data - such as `hierarchyParentsOfSelf`. It can also invert type of returned entities in case extra result
  // `hierarchyOfSelf` is requested.
  bool withHierarchy = 6;
  // Contains `true` when entities of this type holds price information.
  //
  // Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce
  // systems and highly affects performance of the entities filtering and sorting, they deserve first class support
  // in entity model. It is pretty common in B2B systems single product has assigned dozens of prices for the different
  // customers.
  //
  // Specifying prices on entity allows usage of `priceValidIn`, `priceInCurrency`
  // `priceBetween`, and `priceInPriceLists` filtering constraints and also `priceNatural`,
  // ordering of the entities. Additional extra result
  // `priceHistogram` and requirement `priceType` can be used in query as well.
  bool withPrice = 7;
  // Determines how many fractional places are important when entities are compared during filtering or sorting. It is
  // important to know that all prices will be converted to `Int`, so any of the price values
  // (either with or without tax) must not ever exceed maximum limits of `Int` type when scaling
  // the number by the power of ten using `indexedPricePlaces` as exponent.
  int32 indexedPricePlaces = 8;
  // Contains set of all `Locale` that could be used for localized `AttributeSchema` or `AssociatedDataSchema`.
  // Enables using `entityLocaleEquals` filtering constraint in query.
  repeated GrpcLocale locales = 9;
  // Contains set of all `Currency` that could be used for `prices` in entities of this type.
  repeated GrpcCurrency currencies = 10;
  // Contains index of all `AttributeSchema` that could be used as attributes of entity of this type.
  //
  // Entity (global) attributes allows defining set of data that are fetched in bulk along with the entity body.
  // Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
  // (`AttributeSchema.sortable`). Attributes are not automatically indexed in order not to waste precious
  // memory space for data that will never be used in search queries.
  //
  // Filtering in attributes is executed by using constraints like `and`,
  // `not`, `attributeEquals`, `attributeContains`
  // and many others. Sorting can be achieved with `attributeNatural` or others.
  //
  // Attributes are not recommended for bigger data as they are all loaded at once requested.
  // Large data that are occasionally used store in `associatedData`.
  map<string, GrpcAttributeSchema> attributes = 11;
  // Contains index of all `AssociatedDataSchema` that could be used as associated data of entity of this type.
  //
  // Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
  // along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
  // in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
  // binary arrays representing entire files (i.e. pictures, documents).
  //
  // The search query must contain specific associated data fields in order
  // associated data are fetched along with the entity. Associated data are stored and fetched separately by their name.
  map<string, GrpcAssociatedDataSchema> associatedData = 12;
  // Contains index of all `ReferenceSchema` that could be used as references of entity of this type.
  //
  // References refer to other entities (of same or different entity type).
  // Allows entity filtering (but not sorting) of the entities by using `facetInSet` constraint
  // and statistics computation when `facetStatistics` extra result is requested. Reference
  // is uniquely represented by int positive number (max. (2^63)-1) and entity type and can be
  // part of multiple reference groups, that are also represented by int and entity type.
  //
  // Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
  // of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
  // to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
  // group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
  // Evita.
  //
  // References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
  // The search query must contain specific `referenceContent` requirement in order
  // references are fetched along with the entity.
  map<string, GrpcReferenceSchema> references = 13;
  // Evolution mode allows to specify how strict is evitaDB when unknown information is presented to her for the first
  // time. When no evolution mode is set, each violation of the `EntitySchema` is
  // reported by an exception. This behaviour can be changed by this evolution mode however.
  repeated GrpcEvolutionMode evolutionMode = 14;
  // Contains index of definitions of all sortable attribute compounds defined in this schema.
  map<string, GrpcSortableAttributeCompoundSchema> sortableAttributeCompounds = 15;
  // Contains entity type converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 16;
}

// This is the definition object for attributes that are stored along with
// entity. Definition objects allow to describe the structure of the entity type so that
// in any time everyone can consult complete structure of the entity type. Definition object is similar to Java reflection
// process where you can also at any moment see which fields and methods are available for the class.
//
// Entity attributes allows defining set of data that are fetched in bulk along with the entity body.
// Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
// (`AttributeSchema.sortable`). Attributes are not automatically indexed in order not to waste precious
// memory space for data that will never be used in search queries.
//
// Filtering in attributes is executed by using constraints like `and`,
// `not`, `attributeEquals`, `attributeContains`
// and many others. Sorting can be achieved with `attributeNatural` or others.
//
// Attributes are not recommended for bigger data as they are all loaded at once requested.
// Large data that are occasionally used store in `associatedData`.
message GrpcAttributeSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // When this attribute schema belongs to a catalog - it is global and can have globally unique attributes enforced across whole catalog.
  GrpcAttributeSchemaType schemaType = 2;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 3;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 4;
  // When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity
  // having certain value of this attribute among other entities in the same collection.
  //
  // As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's
  // better to have this ensured by the database engine.
  GrpcAttributeUniquenessType unique = 5;
  GrpcGlobalAttributeUniquenessType uniqueGlobally = 6;
  // When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute
  // as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies
  // (memory/disk) space in the form of index.
  //
  // When attribute is filterable, extra result `attributeHistogram`
  // can be requested for this attribute.
  bool filterable = 7;
  // When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute
  // as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies
  // (memory/disk) space in the form of index.
  bool sortable = 8;
  // When attribute is localized, it has to be ALWAYS used in connection with specific `Locale`.
  bool localized = 9;
  // When attribute is nullable, its values may be missing in the entities. Otherwise, the system will enforce
  // non-null checks upon upserting of the entity.
  bool nullable = 10;
	// If an attribute is flagged as representative, it should be used in developer tools along with the entity's
	// primary key to describe the entity or reference to that entity. The flag is completely optional and doesn't
	// affect the core functionality of the database in any way. However, if it's used correctly, it can be very
	// helpful to developers in quickly finding their way around the data. There should be very few representative
	// attributes in the entity type, and the unique ones are usually the best to choose.
  bool representative = 11;
  // Data type of the attribute. Must be one of Evita-supported values.
  // Internally the scalar is converted into Java-corresponding data type.
  GrpcEvitaDataType type = 12;
  // Default value is used when the entity is created without this attribute specified. Default values allow to pass
  // non-null checks even if no attributes of such name are specified.
  GrpcEvitaValue defaultValue = 13;
  // Determines how many fractional places are important when entities are compared during filtering or sorting. It is
  // significant to know that all values of this attribute will be converted to `Int`, so the attribute
  // number must not ever exceed maximum limits of `Int` type when scaling the number by the power
  // of ten using `indexedDecimalPlaces` as exponent.
  int32 indexedDecimalPlaces = 14;
  // Contains attribute name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 15;
}

// This is the definition object for associated data that is stored along with
// entity. Definition objects allow to describe the structure of the entity type so that
// in any time everyone can consult complete structure of the entity type.
//
// Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
// along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
// in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
// binary arrays representing entire files (i.e. pictures, documents).
message GrpcAssociatedDataSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  google.protobuf.StringValue description = 2;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 3;
  // Data type of the associated data. Must be one of Evita-supported values.
  // Internally the type is converted into Java-corresponding data type.
  // The type may be scalar type or may represent complex object type (JSON).
  GrpcEvitaAssociatedDataDataType.GrpcEvitaDataType type = 4;
  // Localized associated data has to be ALWAYS used in connection with specific `Locale`. In other
  // words - it cannot be stored unless associated locale is also provided.
  bool localized = 5;
  // When associated data is nullable, its values may be missing in the entities. Otherwise, the system will enforce
  // non-null checks upon upserting of the entity.
  bool nullable = 6;
  // Contains associated data name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 7;
}

// This is the definition object for reference that is stored along with
// entity. Definition objects allow to describe the structure of the entity type so that
// in any time everyone can consult complete structure of the entity type.
//
// The references refer to other entities (of same or different entity type).
// Allows entity filtering (but not sorting) of the entities by using `facet_{name}_inSet` query
// and statistics computation if when requested. Reference
// is uniquely represented by int positive number (max. (2^63)-1) and entity type and can be
// part of multiple reference groups, that are also represented by int and entity type.
//
// Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
// of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
// to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
// group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
// Evita.
//
// References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
message GrpcReferenceSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 2;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 3;
  // Cardinality describes the expected count of relations of this type. In evitaDB we define only one-way
  // relationship from the perspective of the entity. We stick to the ERD modelling
  // [standards](https://www.gleek.io/blog/crows-foot-notation.html) here. Cardinality affect the design
  // of the client API (returning only single reference or collections) and also help us to protect the consistency
  // of the data so that conforms to the creator mental model.
  GrpcCardinality cardinality = 4;
  // Reference to `Entity.type` of the referenced entity. Might be also any `String`
  // that identifies type some external resource not maintained by Evita.
  string entityType = 5;
  // Contains `true` if `entityType` refers to any existing entity that is maintained by Evita.
  bool entityTypeRelatesToEntity = 6;
  // Reference to `Entity.type` of the referenced entity. Might be also `String` that identifies type some external
  // resource not maintained by Evita.
  google.protobuf.StringValue groupType = 7;
  // Contains `true` if `groupType` refers to any existing entity that is maintained by Evita.
  bool groupTypeRelatesToEntity = 8;
  // Contains `true` if the index for this reference should be created and maintained allowing to filter by
  // `reference_{reference name}_having` filtering constraints. Index is also required when reference is
  // `faceted`.
  //
  // Do not mark reference as faceted unless you know that you'll need to filter/sort entities by this reference.
  // Each indexed reference occupies (memory/disk) space in the form of index. When reference is not indexed,
  // the entity cannot be looked up by reference attributes or relation existence itself, but the data can be
  // fetched.
  bool indexed = 9;
  // Contains `true` if the statistics data for this reference should be maintained and this allowing to get
  // `facetStatistics` for this reference or use `facet_{reference name}_inSet`
  // filtering constraint.
  //
  // Do not mark reference as faceted unless you want it among `facetStatistics`. Each faceted reference
  // occupies (memory/disk) space in the form of index.
  //
  // Reference that was marked as faceted is called Facet.
  bool faceted = 10;
  // Attributes related to reference allows defining set of data that are fetched in bulk along with the entity body.
  // Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
  // (`AttributeSchema.filterable`). Attributes are not automatically indexed in order not to waste precious
  // memory space for data that will never be used in search queries.
  //
  // Filtering in attributes is executed by using constraints like `and`,
  // `not`, `attributeEquals`, `attributeContains`
  // and many others. Sorting can be achieved with `attributeNatural` or others.
  //
  // Attributes are not recommended for bigger data as they are all loaded at once.
  map<string, GrpcAttributeSchema> attributes = 11;
  // Contains index of definitions of all sortable attribute compounds defined in this schema.
  map<string, GrpcSortableAttributeCompoundSchema> sortableAttributeCompounds = 12;
  // Contains reference name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 13;
}

// Sortable attribute compounds are used to sort entities or references by multiple attributes at once. evitaDB
// requires a pre-sorted index in order to be able to sort entities or references by particular attribute or
// combination of attributes, so it can deliver the results as fast as possible. Sortable attribute compounds
// are filtered the same way as attributes - using natural ordering constraint.
message GrpcSortableAttributeCompoundSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 2;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 3;
  // Collection of attribute elements that define the sortable compound. The order of the elements
  // is important, as it defines the order of the sorting.
  repeated GrpcAttributeElement attributeElements = 4;
  // Contains attribute compound name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 5;
}

// Attribute element is a part of the sortable compound. It defines the attribute name, the direction of the
// sorting and the behaviour of the null values. The attribute name refers to the existing attribute defined in the
// schema.
message GrpcAttributeElement {
  // Name of the existing attribute in the same schema.
  string attributeName = 1;
  // Direction of the sorting.
  GrpcOrderDirection direction = 2;
  // Behaviour of the null values.
  GrpcOrderBehaviour behaviour = 3;
}
