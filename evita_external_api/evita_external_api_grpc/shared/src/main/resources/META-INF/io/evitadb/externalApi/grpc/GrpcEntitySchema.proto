syntax = "proto3";

package io.evitadb.externalApi.grpc.generated;
option java_multiple_files = true;
option csharp_namespace = "EvitaDB";

import "GrpcEvitaDataTypes.proto";
import "GrpcEnums.proto";
import "google/protobuf/wrappers.proto";

// This is the definition object for entity. Definition objects allow to describe the structure
// of the entity type so that in any time everyone can consult complete structure of the entity type.
//
// Based on our experience we've designed following data model for handling entities in evitaDB. Model is rather complex
// but was designed to limit amount of data fetched from database and minimize an amount of data that are indexed and subject
// to search.
//
// Minimal entity definition consists of:
// - entity type and
// - primary key (even this is optional and may be autogenerated by the database).
//
// Other entity data is purely optional and may not be used at all.
message GrpcEntitySchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // Contains version of this entity schema and gets increased with any entity type update. Allows to execute
  // optimistic locking i.e. avoiding parallel modifications.
  int32 version = 2;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 3;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 4;
  // Contains `true` when primary keys of entities of this type will not be provided by the external systems and Evita
  // is responsible for generating unique primary keys for the entity on insertion.
  //
  // Generated key is guaranteed to be unique, but may not represent continuous ascending series. Generated key
  // will be always greater than zero.
  bool withGeneratedPrimaryKey = 5;
  // Contains `true` when entities of this type are organized in a tree like structure (hierarchy) where certain entities
  // are subordinate of other entities.
  //
  // Entities may be organized in hierarchical fashion. That means that entity may refer to single parent entity and may be
  // referred by multiple child entities. Hierarchy is always composed of entities of same type.
  // Each entity must be part of at most single hierarchy (tree).
  //
  // Hierarchy can limit returned entities by using filtering constraints. It's also used for
  // computation of extra data - such as `hierarchyParentsOfSelf`. It can also invert type of returned entities in case extra result
  // `hierarchyOfSelf` is requested.
  bool withHierarchy = 6;
  // Contains `true` when entities of this type holds price information.
  //
  // Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce
  // systems and highly affects performance of the entities filtering and sorting, they deserve first class support
  // in entity model. It is pretty common in B2B systems single product has assigned dozens of prices for the different
  // customers.
  //
  // Specifying prices on entity allows usage of `priceValidIn`, `priceInCurrency`
  // `priceBetween`, and `priceInPriceLists` filtering constraints and also `priceNatural`,
  // ordering of the entities. Additional extra result
  // `priceHistogram` and requirement `priceType` can be used in query as well.
  bool withPrice = 7;
  // Determines how many fractional places are important when entities are compared during filtering or sorting. It is
  // important to know that all prices will be converted to `Int`, so any of the price values
  // (either with or without tax) must not ever exceed maximum limits of `Int` type when scaling
  // the number by the power of ten using `indexedPricePlaces` as exponent.
  int32 indexedPricePlaces = 8;
  // Contains set of all `Locale` that could be used for localized `AttributeSchema` or `AssociatedDataSchema`.
  // Enables using `entityLocaleEquals` filtering constraint in query.
  repeated GrpcLocale locales = 9;
  // Contains set of all `Currency` that could be used for `prices` in entities of this type.
  repeated GrpcCurrency currencies = 10;
  // Contains index of all `AttributeSchema` that could be used as attributes of entity of this type.
  //
  // Entity (global) attributes allows defining set of data that are fetched in bulk along with the entity body.
  // Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
  // (`AttributeSchema.sortable`). Attributes are not automatically indexed in order not to waste precious
  // memory space for data that will never be used in search queries.
  //
  // Filtering in attributes is executed by using constraints like `and`,
  // `not`, `attributeEquals`, `attributeContains`
  // and many others. Sorting can be achieved with `attributeNatural` or others.
  //
  // Attributes are not recommended for bigger data as they are all loaded at once requested.
  // Large data that are occasionally used store in `associatedData`.
  map<string, GrpcAttributeSchema> attributes = 11;
  // Contains index of all `AssociatedDataSchema` that could be used as associated data of entity of this type.
  //
  // Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
  // along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
  // in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
  // binary arrays representing entire files (i.e. pictures, documents).
  //
  // The search query must contain specific associated data fields in order
  // associated data are fetched along with the entity. Associated data are stored and fetched separately by their name.
  map<string, GrpcAssociatedDataSchema> associatedData = 12;
  // Contains index of all `ReferenceSchema` that could be used as references of entity of this type.
  //
  // References refer to other entities (of same or different entity type).
  // Allows entity filtering (but not sorting) of the entities by using `facetInSet` constraint
  // and statistics computation when `facetStatistics` extra result is requested. Reference
  // is uniquely represented by int positive number (max. (2^63)-1) and entity type and can be
  // part of multiple reference groups, that are also represented by int and entity type.
  //
  // Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
  // of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
  // to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
  // group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
  // Evita.
  //
  // References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
  // The search query must contain specific `referenceContent` requirement in order
  // references are fetched along with the entity.
  map<string, GrpcReferenceSchema> references = 13;
  // Evolution mode allows to specify how strict is evitaDB when unknown information is presented to her for the first
  // time. When no evolution mode is set, each violation of the `EntitySchema` is
  // reported by an exception. This behaviour can be changed by this evolution mode however.
  repeated GrpcEvolutionMode evolutionMode = 14;
  // Contains index of definitions of all sortable attribute compounds defined in this schema.
  map<string, GrpcSortableAttributeCompoundSchema> sortableAttributeCompounds = 15;
  // Contains entity type converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 16;
	// Contains set of all scopes the entity is indexed in and can be used for filtering entities and computation of
	// extra data. If the hierarchy information is not indexed, it is still available on the entity itself (i.e. entity
	// can define its parent entity), but it is not possible to work with the hierarchy information in any other way
	// (calculating parent chain, children, siblings, etc.).
  repeated GrpcEntityScope hierarchyIndexedInScopes = 17;
	// Contains set of all scopes the price information is indexed in and can be used for filtering entities and computation
	// of extra data. If the price information is not indexed, it is still available on the entity itself (i.e. entity
	// can define its price), but it is not possible to work with the price information in any other way (calculating
	// price histogram, filtering, sorting by price, etc.).
	//
	// Prices can be also set as non-indexed individually by setting {@link PriceContract#indexed()} to false.
  repeated GrpcEntityScope priceIndexedInScopes = 18;
  // Contains current version of the catalog schema this entity schema belongs to.
  int64 catalogSchemaVersion = 19;
}

// This is the definition object for attributes that are stored along with
// entity. Definition objects allow to describe the structure of the entity type so that
// in any time everyone can consult complete structure of the entity type. Definition object is similar to Java reflection
// process where you can also at any moment see which fields and methods are available for the class.
//
// Entity attributes allows defining set of data that are fetched in bulk along with the entity body.
// Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
// (`AttributeSchema.sortable`). Attributes are not automatically indexed in order not to waste precious
// memory space for data that will never be used in search queries.
//
// Filtering in attributes is executed by using constraints like `and`,
// `not`, `attributeEquals`, `attributeContains`
// and many others. Sorting can be achieved with `attributeNatural` or others.
//
// Attributes are not recommended for bigger data as they are all loaded at once requested.
// Large data that are occasionally used store in `associatedData`.
message GrpcAttributeSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // When this attribute schema belongs to a catalog - it is global and can have globally unique attributes enforced across whole catalog.
  GrpcAttributeSchemaType schemaType = 2;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 3;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 4;
  // When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity
  // having certain value of this attribute among other entities in the same collection.
  //
  // As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's
  // better to have this ensured by the database engine.
  // deprecated in favor of `uniqueInScopes`
  GrpcAttributeUniquenessType unique = 5 [deprecated = true];
  // When attribute is unique globally it is automatically filterable, and it is ensured there is exactly one single
  // entity having certain value of this attribute in entire {@link CatalogContract}.
  // {@link AttributeSchemaContract#getType() Type} of the unique attribute must implement {@link Comparable} interface.
  //
  // As an example of unique attribute can be URL - there is no sense in having two entities with same URL, and it's
  // better to have this ensured by the database engine.
  // deprecated in favor of `uniqueGloballyInScopes`
  GrpcGlobalAttributeUniquenessType uniqueGlobally = 6 [deprecated = true];
  // When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute
  // as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies
  // (memory/disk) space in the form of index.
  //
  // When attribute is filterable, extra result `attributeHistogram`
  // can be requested for this attribute.
  // deprecated in favor of `filterableInScopes`
  bool filterable = 7 [deprecated = true];
  // When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute
  // as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies
  // (memory/disk) space in the form of index.
  // deprecated in favor of `sortableInScopes`
  bool sortable = 8 [deprecated = true];
  // When attribute is localized, it has to be ALWAYS used in connection with specific `Locale`.
  bool localized = 9;
  // When attribute is nullable, its values may be missing in the entities. Otherwise, the system will enforce
  // non-null checks upon upserting of the entity.
  bool nullable = 10;
  // Representative flag marks the attribute as one of the most important attributes in the entity, or when used
  // on reference level in the {@link ReferenceSchemaContract} it marks attributes distinguishing duplicated
  // references to the same entity and is a key attribute for creating distinct indexes for such references.
  //
  // In overall, representative attributes should be used in developer tools along with the entity's primary key to
  // describe the entity or reference to that entity. If the flag is used correctly, it can be very helpful to
  // developers in quickly finding their way around the data. There should be very few representative attributes
  // in the entity / reference type, and the ones with uniqueness significance are usually the best to choose.
  bool representative = 11;
  // Data type of the attribute. Must be one of Evita-supported values.
  // Internally the scalar is converted into Java-corresponding data type.
  GrpcEvitaDataType type = 12;
  // Default value is used when the entity is created without this attribute specified. Default values allow to pass
  // non-null checks even if no attributes of such name are specified.
  GrpcEvitaValue defaultValue = 13;
  // Determines how many fractional places are important when entities are compared during filtering or sorting. It is
  // significant to know that all values of this attribute will be converted to `Int`, so the attribute
  // number must not ever exceed maximum limits of `Int` type when scaling the number by the power
  // of ten using `indexedDecimalPlaces` as exponent.
  int32 indexedDecimalPlaces = 14;
  // Contains attribute name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 15;
  // Contains true if the attribute was inherited from the original object via reflected reference relation
  bool inherited = 16;
  // When attribute is unique it is automatically filterable, and it is ensured there is exactly one single entity
  // having certain value of this attribute among other entities in the same collection.
  //
  // As an example of unique attribute can be EAN - there is no sense in having two entities with same EAN, and it's
  // better to have this ensured by the database engine.
  repeated GrpcScopedAttributeUniquenessType uniqueInScopes = 17;
  // When attribute is unique globally it is automatically filterable, and it is ensured there is exactly one single
  // entity having certain value of this attribute in entire {@link CatalogContract}.
  // {@link AttributeSchemaContract#getType() Type} of the unique attribute must implement {@link Comparable} interface.
  //
  // As an example of unique attribute can be URL - there is no sense in having two entities with same URL, and it's
  // better to have this ensured by the database engine.
  repeated GrpcScopedGlobalAttributeUniquenessType uniqueGloballyInScopes = 18;
  // When attribute is filterable, it is possible to filter entities by this attribute. Do not mark attribute
  // as filterable unless you know that you'll search entities by this attribute. Each filterable attribute occupies
  // (memory/disk) space in the form of index.
  //
  // When attribute is filterable, extra result `attributeHistogram`
  // can be requested for this attribute.
  repeated GrpcEntityScope filterableInScopes = 19;
  // When attribute is sortable, it is possible to sort entities by this attribute. Do not mark attribute
  // as sortable unless you know that you'll sort entities along this attribute. Each sortable attribute occupies
  // (memory/disk) space in the form of index.
  repeated GrpcEntityScope sortableInScopes = 20;
}

// This is the definition object for associated data that is stored along with
// entity. Definition objects allow to describe the structure of the entity type so that
// in any time everyone can consult complete structure of the entity type.
//
// Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
// along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
// in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
// binary arrays representing entire files (i.e. pictures, documents).
message GrpcAssociatedDataSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  google.protobuf.StringValue description = 2;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 3;
  // Data type of the associated data. Must be one of Evita-supported values.
  // Internally the type is converted into Java-corresponding data type.
  // The type may be scalar type or may represent complex object type (JSON).
  GrpcEvitaAssociatedDataDataType.GrpcEvitaDataType type = 4;
  // Localized associated data has to be ALWAYS used in connection with specific `Locale`. In other
  // words - it cannot be stored unless associated locale is also provided.
  bool localized = 5;
  // When associated data is nullable, its values may be missing in the entities. Otherwise, the system will enforce
  // non-null checks upon upserting of the entity.
  bool nullable = 6;
  // Contains associated data name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 7;
}

// This is the definition object for reference that is stored along with
// entity. Definition objects allow to describe the structure of the entity type so that
// in any time everyone can consult complete structure of the entity type.
//
// The references refer to other entities (of same or different entity type).
// Allows entity filtering (but not sorting) of the entities by using `facet_{name}_inSet` query
// and statistics computation if when requested. Reference
// is uniquely represented by int positive number (max. (2^63)-1) and entity type and can be
// part of multiple reference groups, that are also represented by int and entity type.
//
// Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
// of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
// to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
// group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
// Evita.
//
// References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
message GrpcReferenceSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 2;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 3;
  // Cardinality describes the expected count of relations of this type. In evitaDB we define only one-way
  // relationship from the perspective of the entity. We stick to the ERD modelling
  // [standards](https://www.gleek.io/blog/crows-foot-notation.html) here. Cardinality affect the design
  // of the client API (returning only single reference or collections) and also help us to protect the consistency
  // of the data so that conforms to the creator mental model.
  GrpcCardinality cardinality = 4;
  // Reference to `Entity.type` of the referenced entity. Might be also any `String`
  // that identifies type some external resource not maintained by Evita.
  string entityType = 5;
  // Contains `true` if `entityType` refers to any existing entity that is maintained by Evita.
  // DEPRECATED!!! use referencedEntityTypeManaged instead
  bool entityTypeRelatesToEntity = 6 [deprecated = true];
  // Reference to `Entity.type` of the referenced entity. Might be also `String` that identifies type some external
  // resource not maintained by Evita.
  google.protobuf.StringValue groupType = 7;
  // Contains `true` if `groupType` refers to any existing entity that is maintained by Evita.
  // DEPRECATED!!! use referencedGroupTypeManaged instead
  bool groupTypeRelatesToEntity = 8 [deprecated = true];
  // Contains `true` if the index for this reference should be created and maintained allowing to filter by
  // `reference_{reference name}_having` filtering constraints. Index is also required when reference is
  // `faceted`.
  //
  // Do not mark reference as faceted unless you know that you'll need to filter/sort entities by this reference.
  // Each indexed reference occupies (memory/disk) space in the form of index. When reference is not indexed,
  // the entity cannot be looked up by reference attributes or relation existence itself, but the data can be
  // fetched.
  // deprecated in favor of `indexedInScopes`
  bool indexed = 9 [deprecated = true];
  // Contains `true` if the statistics data for this reference should be maintained and this allowing to get
  // `facetStatistics` for this reference or use `facet_{reference name}_inSet`
  // filtering constraint.
  //
  // Do not mark reference as faceted unless you want it among `facetStatistics`. Each faceted reference
  // occupies (memory/disk) space in the form of index.
  //
  // Reference that was marked as faceted is called Facet.
  // deprecated in favor of `facetedInScopes`
  bool faceted = 10 [deprecated = true];
  // Attributes related to reference allows defining set of data that are fetched in bulk along with the entity body.
  // Attributes may be indexed for fast filtering (`AttributeSchema.filterable`) or can be used to sort along
  // (`AttributeSchema.filterable`). Attributes are not automatically indexed in order not to waste precious
  // memory space for data that will never be used in search queries.
  //
  // Filtering in attributes is executed by using constraints like `and`,
  // `not`, `attributeEquals`, `attributeContains`
  // and many others. Sorting can be achieved with `attributeNatural` or others.
  //
  // Attributes are not recommended for bigger data as they are all loaded at once.
  map<string, GrpcAttributeSchema> attributes = 11;
  // Contains index of definitions of all sortable attribute compounds defined in this schema.
  map<string, GrpcSortableAttributeCompoundSchema> sortableAttributeCompounds = 12;
  // Contains reference name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 13;
  // Contains referenced entity name converted to different naming conventions (only for non-managed entities).
  repeated GrpcNameVariant entityTypeNameVariant = 14;
  // Contains referenced group name converted to different naming conventions (only for non-managed entities).
  repeated GrpcNameVariant groupTypeNameVariant = 15;
  // Contains `true` if `entityType` refers to any existing entity that is maintained by Evita.
  bool referencedEntityTypeManaged = 16;
  // Contains `true` if `groupType` refers to any existing entity that is maintained by Evita.
  bool referencedGroupTypeManaged = 17;
  // Name of the reflected reference of the target referencedEntityType(). The referenced entity must contain reference
  // of such name and this reference must target the entity where the reflected reference is defined, and the target
  // entity must be managed on both sides of the relation.
  google.protobuf.StringValue reflectedReferenceName = 18;
  // Contains true if the description of the reflected reference is inherited from the target reference.
  bool descriptionInherited = 19;
  // Contains true if the deprecated flag of the reflected reference is inherited from the target reference.
  bool deprecationNoticeInherited = 20;
  // Contains true if the cardinality of the reflected reference is inherited from the target reference.
  bool cardinalityInherited = 21;
  // Contains true if the faceted property settings of the reflected reference is inherited from the target reference.
  bool facetedInherited = 22;
  // Contains true if the attributes of the reflected reference are inherited from the target reference.
  GrpcAttributeInheritanceBehavior attributeInheritanceBehavior = 23;
  // The array of attribute names that are inherited / excluded from inheritance based on the value of
  // attributeInheritanceBehavior property.
  repeated string attributeInheritanceFilter = 24;
  // Contains true if the indexed property settings of the reflected reference is inherited from the target reference.
  bool indexedInherited = 25;
  // Contains `true` if the index for this reference should be created and maintained allowing to filter by
  // `reference_{reference name}_having` filtering constraints. Index is also required when reference is
  // `faceted`.
  //
  // Do not mark reference as faceted unless you know that you'll need to filter/sort entities by this reference.
  // Each indexed reference occupies (memory/disk) space in the form of index. When reference is not indexed,
  // the entity cannot be looked up by reference attributes or relation existence itself, but the data can be
  // fetched.
  // deprecated in favor of `scopedIndexTypes`
  repeated GrpcEntityScope indexedInScopes = 26 [deprecated = true];
  // Contains `true` if the statistics data for this reference should be maintained and this allowing to get
  // `facetStatistics` for this reference or use `facet_{reference name}_inSet`
  // filtering constraint.
  //
  // Do not mark reference as faceted unless you want it among `facetStatistics`. Each faceted reference
  // occupies (memory/disk) space in the form of index.
  //
  // Reference that was marked as faceted is called Facet.
  repeated GrpcEntityScope facetedInScopes = 27;
  // Scoped reference index types that define both the scope and the type of index for the reference.
  // This replaces the deprecated `indexedInScopes` field with more granular control over indexing.
  repeated GrpcScopedReferenceIndexType scopedIndexTypes = 28;
}

// Sortable attribute compounds are used to sort entities or references by multiple attributes at once. evitaDB
// requires a pre-sorted index in order to be able to sort entities or references by particular attribute or
// combination of attributes, so it can deliver the results as fast as possible. Sortable attribute compounds
// are filtered the same way as attributes - using natural ordering constraint.
message GrpcSortableAttributeCompoundSchema {
  // Contains unique name of the model. Case-sensitive. Distinguishes one model item from another
  // within single entity instance.
  string name = 1;
  // Contains description of the model is optional but helps authors of the schema / client API to better
  // explain the original purpose of the model to the consumers.
  google.protobuf.StringValue description = 2;
  // Deprecation notice contains information about planned removal of this entity from the model / client API.
  // This allows to plan and evolve the schema allowing clients to adapt early to planned breaking changes.
  //
  // If notice is `null`, this schema is considered not deprecated.
  google.protobuf.StringValue deprecationNotice = 3;
  // Collection of attribute elements that define the sortable compound. The order of the elements
  // is important, as it defines the order of the sorting.
  repeated GrpcAttributeElement attributeElements = 4;
  // Contains attribute compound name converted to different naming conventions.
  repeated GrpcNameVariant nameVariant = 5;
  // Contains true if the attribute was inherited from the original object via reflected reference relation
  bool inherited = 6;
  // When attribute sortable compound is indexed, it is possible to sort entities by this calculated attribute compound.
  // This property contains set of all scopes this attribute compound is indexed in.
  repeated GrpcEntityScope indexedInScopes = 7;
}

// Attribute element is a part of the sortable compound. It defines the attribute name, the direction of the
// sorting and the behaviour of the null values. The attribute name refers to the existing attribute defined in the
// schema.
message GrpcAttributeElement {
  // Name of the existing attribute in the same schema.
  string attributeName = 1;
  // Direction of the sorting.
  GrpcOrderDirection direction = 2;
  // Behaviour of the null values.
  GrpcOrderBehaviour behaviour = 3;
}
