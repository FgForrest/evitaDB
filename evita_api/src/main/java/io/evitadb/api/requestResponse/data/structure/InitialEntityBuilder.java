/*
 *
 *                         _ _        ____  ____
 *               _____   _(_) |_ __ _|  _ \| __ )
 *              / _ \ \ / / | __/ _` | | | |  _ \
 *             |  __/\ V /| | || (_| | |_| | |_) |
 *              \___| \_/ |_|\__\__,_|____/|____/
 *
 *   Copyright (c) 2023-2025
 *
 *   Licensed under the Business Source License, Version 1.1 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   https://github.com/FgForrest/evitaDB/blob/master/LICENSE
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package io.evitadb.api.requestResponse.data.structure;

import io.evitadb.api.exception.InvalidMutationException;
import io.evitadb.api.exception.ReferenceNotKnownException;
import io.evitadb.api.requestResponse.data.AssociatedDataContract;
import io.evitadb.api.requestResponse.data.AttributesContract;
import io.evitadb.api.requestResponse.data.EntityClassifierWithParent;
import io.evitadb.api.requestResponse.data.PriceContract;
import io.evitadb.api.requestResponse.data.PriceInnerRecordHandling;
import io.evitadb.api.requestResponse.data.PricesContract;
import io.evitadb.api.requestResponse.data.ReferenceContract;
import io.evitadb.api.requestResponse.data.ReferenceEditor.ReferenceBuilder;
import io.evitadb.api.requestResponse.data.ReferencesContract;
import io.evitadb.api.requestResponse.data.Versioned;
import io.evitadb.api.requestResponse.data.mutation.EntityMutation;
import io.evitadb.api.requestResponse.data.mutation.EntityMutation.EntityExistence;
import io.evitadb.api.requestResponse.data.mutation.EntityUpsertMutation;
import io.evitadb.api.requestResponse.data.mutation.LocalMutation;
import io.evitadb.api.requestResponse.data.mutation.associatedData.AssociatedDataMutation;
import io.evitadb.api.requestResponse.data.mutation.attribute.AttributeMutation;
import io.evitadb.api.requestResponse.data.mutation.parent.SetParentMutation;
import io.evitadb.api.requestResponse.data.mutation.reference.ReferenceKey;
import io.evitadb.api.requestResponse.data.mutation.scope.SetEntityScopeMutation;
import io.evitadb.api.requestResponse.schema.Cardinality;
import io.evitadb.api.requestResponse.schema.EntitySchemaContract;
import io.evitadb.api.requestResponse.schema.EvolutionMode;
import io.evitadb.api.requestResponse.schema.dto.EntitySchema;
import io.evitadb.dataType.DateTimeRange;
import io.evitadb.dataType.Scope;
import io.evitadb.utils.Assert;
import lombok.experimental.Delegate;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.io.Serial;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Currency;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.Optional.of;
import static java.util.Optional.ofNullable;

/**
 * Builder that is used to create the entity.
 * Due to performance reasons (see DirectWriteOrOperationLog microbenchmark) there is special
 * implementation for the situation when entity is newly created. In this case we know everything
 * is new and we don't need to closely monitor the changes so this can speed things up.
 *
 * @author Jan NovotnÃ½ (novotny@fg.cz), FG Forrest a.s. (c) 2021
 */
public class InitialEntityBuilder implements InternalEntityBuilder {
	@Serial private static final long serialVersionUID = -3674623071115207036L;

	/**
	 * Logical entity type (a.k.a. collection name) this builder creates.
	 * Matches {@link #schema} name and is kept for quick access.
	 */
	private final String type;
	/**
	 * Schema snapshot used to validate attributes, associated data, references and prices.
	 * For new entities we use lightweight {@link EntitySchema#_internalBuild(String)} when only type is known.
	 */
	private final EntitySchemaContract schema;
	/**
	 * Primary key of the entity if it is known upfront. For newly created entities it is usually {@code null}
	 * and will be generated by the persistence layer.
	 */
	private final Integer primaryKey;
	/**
	 * Target {@link Scope} for the entity. Defaults to {@link Scope#DEFAULT_SCOPE}.
	 */
	private Scope scope;
	/**
	 * Lazy-initialized builder for entity attributes.
	 */
	@Nullable private InitialEntityAttributesBuilder attributesBuilder;
	/**
	 * Lazy-initialized builder for associated data.
	 */
	@Nullable private InitialAssociatedDataBuilder associatedDataBuilder;
	/**
	 * Lazy-initialized builder for prices.
	 */
	@Nullable private InitialPricesBuilder pricesBuilder;
	/**
	 * Lazy-initialized builder for references.
	 */
	@Nullable private InitialReferencesBuilder referencesBuilder;
	/**
	 * Optional parent primary key when hierarchy is used, otherwise {@code null}.
	 */
	@Nullable private Integer parent;

	/**
	 * Creates a builder for a new entity using only its type. A lightweight schema snapshot is
	 * created internally via {@link EntitySchema#_internalBuild(String)}.
	 *
	 * @param type logical entity type (collection name)
	 */
	public InitialEntityBuilder(@Nonnull String type) {
		this.type = type;
		this.schema = EntitySchema._internalBuild(type);
		this.primaryKey = null;
		this.scope = Scope.DEFAULT_SCOPE;
	}

	/**
	 * Creates a builder for a new entity backed by a concrete {@link EntitySchemaContract}.
	 *
	 * @param schema schema to validate mutations against
	 */
	public InitialEntityBuilder(@Nonnull EntitySchemaContract schema) {
		this.type = schema.getName();
		this.schema = schema;
		this.primaryKey = null;
		this.scope = Scope.DEFAULT_SCOPE;
		Assert.isTrue(
			schema.isWithGeneratedPrimaryKey() || schema.allows(EvolutionMode.ADAPT_PRIMARY_KEY_GENERATION),
			() -> new InvalidMutationException(
				"Schema `" + schema.getName() + "` is not configured to generate primary keys." +
					" Please provide the primary key when creating the entity."
			)
		);
	}

	/**
	 * Creates a builder for a new entity with a known primary key and only a type available.
	 *
	 * @param type       logical entity type (collection name)
	 * @param primaryKey fixed primary key to be used for the entity, may be {@code null}
	 */
	public InitialEntityBuilder(@Nonnull String type, @Nullable Integer primaryKey) {
		this.type = type;
		this.primaryKey = primaryKey;
		this.schema = EntitySchema._internalBuild(type);
		this.scope = Scope.DEFAULT_SCOPE;
	}

	/**
	 * Creates a builder for a new entity backed by a concrete schema with a known primary key.
	 *
	 * @param schema     schema to validate mutations against
	 * @param primaryKey fixed primary key to be used for the entity, may be {@code null}
	 */
	public InitialEntityBuilder(@Nonnull EntitySchemaContract schema, @Nullable Integer primaryKey) {
		this.type = schema.getName();
		this.schema = schema;
		this.primaryKey = primaryKey;
		this.scope = Scope.DEFAULT_SCOPE;
		Assert.isTrue(
			primaryKey == null || !schema.isWithGeneratedPrimaryKey() || schema.allows(EvolutionMode.ADAPT_PRIMARY_KEY_GENERATION),
			() -> new InvalidMutationException(
				"Schema `" + schema.getName() + "` is configured to generate primary keys." +
					" Please call the constructor without primary key parameter."
			)
		);
	}

	/**
	 * Creates a builder and seeds it with the provided state. This factory is primarily used by
	 * deserializers or higher level APIs that already have all pieces computed.
	 *
	 * - All attributes and associated data are inserted via the corresponding initial builders.
	 * - References are collected into a list and indexed into a map; duplicate keys are marked by
	 * storing {@link References#DUPLICATE_REFERENCE} in the map and keeping all entries in the list.
	 * - Price inner record handling is set when provided, then all prices are upserted into the
	 * price builder.
	 * - Scope defaults to {@link Scope#DEFAULT_SCOPE} when {@code null}.
	 *
	 * @param entitySchema             schema that defines the entity
	 * @param primaryKey               optional fixed primary key
	 * @param scope                    initial scope; when {@code null}, {@link Scope#DEFAULT_SCOPE} is used
	 * @param attributeValues          attribute values to seed
	 * @param associatedDataValues     associated data values to seed
	 * @param referenceContracts       references to seed
	 * @param priceInnerRecordHandling optional inner record handling for prices
	 * @param prices                   prices to seed
	 */
	public InitialEntityBuilder(
		@Nonnull EntitySchemaContract entitySchema,
		@Nullable Integer primaryKey,
		@Nullable Scope scope,
		@Nonnull Collection<AttributeValue> attributeValues,
		@Nonnull Collection<AssociatedDataValue> associatedDataValues,
		@Nonnull Collection<ReferenceContract> referenceContracts,
		@Nullable PriceInnerRecordHandling priceInnerRecordHandling,
		@Nonnull Collection<PriceContract> prices
	) {
		this.type = entitySchema.getName();
		this.schema = entitySchema;
		this.primaryKey = primaryKey;
		this.scope = scope == null ? Scope.DEFAULT_SCOPE : scope;
		this.attributesBuilder = attributeValues.isEmpty() ?
			null :
			new InitialEntityAttributesBuilder(this.schema, attributeValues);
		this.associatedDataBuilder = associatedDataValues.isEmpty() ?
			null :
			new InitialAssociatedDataBuilder(this.schema, associatedDataValues);

		if (priceInnerRecordHandling == null && prices.isEmpty()) {
			this.pricesBuilder = null;
		} else {
			this.pricesBuilder = new InitialPricesBuilder(
				this.schema,
				priceInnerRecordHandling,
				prices
			);
		}

		if (referenceContracts.isEmpty()) {
			this.referencesBuilder = null;
		} else {
			this.referencesBuilder = new InitialReferencesBuilder(
				this.schema,
				referenceContracts
			);
		}
	}

	@Override
	public boolean dropped() {
		return false;
	}

	@Override
	public int version() {
		return 1;
	}

	@Override
	@Nonnull
	public String getType() {
		return this.type;
	}

	@Override
	@Nonnull
	public EntitySchemaContract getSchema() {
		return this.schema;
	}

	@Override
	@Nullable
	public Integer getPrimaryKey() {
		return this.primaryKey;
	}

	@Override
	public boolean parentAvailable() {
		return true;
	}

	@Nonnull
	@Override
	public Optional<EntityClassifierWithParent> getParentEntity() {
		return ofNullable(this.parent)
			.map(it -> new EntityReferenceWithParent(this.type, it, null));
	}

	/**
	 * Returns the union of all locales present in attributes and associated data currently staged
	 * in this builder. This is a convenience for constructing the final entity and for validation.
	 */
	@Nonnull
	public Set<Locale> getAllLocales() {
		return Stream.concat(
			             this.attributesBuilder == null ? Stream.empty() : this.attributesBuilder.getAttributeLocales().stream(),
			             this.associatedDataBuilder == null ?
				             Stream.empty() :
				             this.associatedDataBuilder.getAssociatedDataLocales().stream()
		             )
		             .collect(Collectors.toSet());
	}

	/**
	 * Returns the same set as {@link #getAllLocales()}.
	 *
	 * Kept for backwards compatibility and readability at call sites where the context is
	 * clearly about the entity-wide locales.
	 */
	@Nonnull
	public Set<Locale> getLocales() {
		return getAllLocales();
	}

	@Nonnull
	@Override
	public Scope getScope() {
		return this.scope;
	}

	@Nonnull
	@Override
	public EntityBuilder removeAttribute(@Nonnull String attributeName) {
		getAttributesBuilder().removeAttribute(attributeName);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAttribute(
		@Nonnull String attributeName, @Nullable T attributeValue) {
		getAttributesBuilder().setAttribute(attributeName, attributeValue);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAttribute(
		@Nonnull String attributeName, @Nullable T[] attributeValue) {
		getAttributesBuilder().setAttribute(attributeName, attributeValue);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeAttribute(@Nonnull String attributeName, @Nonnull Locale locale) {
		getAttributesBuilder().removeAttribute(attributeName, locale);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAttribute(
		@Nonnull String attributeName, @Nonnull Locale locale, @Nullable T attributeValue) {
		getAttributesBuilder().setAttribute(attributeName, locale, attributeValue);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAttribute(
		@Nonnull String attributeName, @Nonnull Locale locale, @Nullable T[] attributeValue) {
		getAttributesBuilder().setAttribute(attributeName, locale, attributeValue);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder mutateAttribute(@Nonnull AttributeMutation mutation) {
		getAttributesBuilder().mutateAttribute(mutation);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeAssociatedData(@Nonnull String associatedDataName) {
		getAssociatedDataBuilder().removeAssociatedData(associatedDataName);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAssociatedData(
		@Nonnull String associatedDataName, @Nullable T associatedDataValue) {
		getAssociatedDataBuilder().setAssociatedData(associatedDataName, associatedDataValue);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAssociatedData(
		@Nonnull String associatedDataName, @Nonnull T[] associatedDataValue) {
		getAssociatedDataBuilder().setAssociatedData(associatedDataName, associatedDataValue);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeAssociatedData(@Nonnull String associatedDataName, @Nonnull Locale locale) {
		getAssociatedDataBuilder().removeAssociatedData(associatedDataName, locale);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAssociatedData(
		@Nonnull String associatedDataName, @Nonnull Locale locale, @Nullable T associatedDataValue) {
		getAssociatedDataBuilder().setAssociatedData(associatedDataName, locale, associatedDataValue);
		return this;
	}

	@Nonnull
	@Override
	public <T extends Serializable> EntityBuilder setAssociatedData(
		@Nonnull String associatedDataName, @Nonnull Locale locale, @Nullable T[] associatedDataValue) {
		getAssociatedDataBuilder().setAssociatedData(associatedDataName, locale, associatedDataValue);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder mutateAssociatedData(@Nonnull AssociatedDataMutation mutation) {
		getAssociatedDataBuilder().mutateAssociatedData(mutation);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setScope(@Nonnull Scope scope) {
		this.scope = scope;
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setParent(int parentPrimaryKey) {
		assertHierarchyAllowed();
		this.parent = parentPrimaryKey;
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeParent() {
		assertHierarchyAllowed();
		this.parent = null;
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder updateReferences(
		@Nonnull Predicate<ReferenceContract> filter,
		@Nonnull UnaryOperator<ReferenceBuilder> whichIs
	) {
		getReferencesBuilder().updateReferences(filter, whichIs);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setReference(
		@Nonnull String referenceName,
		int referencedPrimaryKey
	) throws ReferenceNotKnownException {
		getReferencesBuilder().setReference(referenceName, referencedPrimaryKey);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setReference(
		@Nonnull String referenceName,
		int referencedPrimaryKey,
		@Nullable Consumer<ReferenceBuilder> whichIs
	) throws ReferenceNotKnownException {
		getReferencesBuilder().setReference(referenceName, referencedPrimaryKey, whichIs);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setReference(
		@Nonnull String referenceName,
		int referencedPrimaryKey,
		@Nonnull Predicate<ReferenceContract> filter,
		@Nonnull UnaryOperator<ReferenceBuilder> whichIs
	) {
		getReferencesBuilder().setReference(referenceName, referencedPrimaryKey, filter, whichIs);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setReference(
		@Nonnull String referenceName,
		@Nonnull String referencedEntityType,
		@Nonnull Cardinality cardinality,
		int referencedPrimaryKey
	) {
		getReferencesBuilder().setReference(
			referenceName, referencedEntityType, cardinality, referencedPrimaryKey
		);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setReference(
		@Nonnull String referenceName,
		@Nonnull String referencedEntityType,
		@Nonnull Cardinality cardinality,
		int referencedPrimaryKey,
		@Nullable Consumer<ReferenceBuilder> whichIs
	) {
		getReferencesBuilder().setReference(
			referenceName, referencedEntityType, cardinality, referencedPrimaryKey, whichIs
		);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder setReference(
		@Nonnull String referenceName,
		@Nonnull String referencedEntityType,
		@Nonnull Cardinality cardinality,
		int referencedPrimaryKey,
		@Nonnull Predicate<ReferenceContract> filter,
		@Nonnull UnaryOperator<ReferenceBuilder> whichIs
	) {
		getReferencesBuilder().setReference(
			referenceName, referencedEntityType, cardinality, referencedPrimaryKey, filter, whichIs
		);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeReference(
		@Nonnull String referenceName,
		int referencedPrimaryKey
	) throws ReferenceNotKnownException {
		getReferencesBuilder().removeReference(referenceName, referencedPrimaryKey);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeReference(@Nonnull ReferenceKey referenceKey) throws ReferenceNotKnownException {
		getReferencesBuilder().removeReference(referenceKey);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeReferences(
		@Nonnull String referenceName,
		int referencedPrimaryKey
	) {
		getReferencesBuilder().removeReferences(referenceName, referencedPrimaryKey);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeReferences(@Nonnull String referenceName) {
		getReferencesBuilder().removeReferences(referenceName);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeReferences(@Nonnull String referenceName, @Nonnull Predicate<ReferenceContract> filter) {
		getReferencesBuilder().removeReferences(referenceName, filter);
		return this;
	}

	@Nonnull
	@Override
	public EntityBuilder removeReferences(@Nonnull Predicate<ReferenceContract> filter) {
		getReferencesBuilder().removeReferences(filter);
		return this;
	}

	@Override
	public int getNextReferenceInternalId() {
		return getReferencesBuilder().getNextReferenceInternalId();
	}

	@Override
	public void addOrReplaceReferenceMutations(@Nonnull ReferenceBuilder referenceBuilder) {
		getReferencesBuilder().addOrReplaceReferenceMutations(referenceBuilder);
	}

	@Override
	public EntityBuilder setPrice(
		int priceId, @Nonnull String priceList, @Nonnull Currency currency, @Nonnull BigDecimal priceWithoutTax,
		@Nonnull BigDecimal taxRate, @Nonnull BigDecimal priceWithTax, boolean indexed
	) {
		getPricesBuilder().setPrice(priceId, priceList, currency, priceWithoutTax, taxRate, priceWithTax, indexed);
		return this;
	}

	@Override
	public EntityBuilder setPrice(
		int priceId, @Nonnull String priceList, @Nonnull Currency currency, @Nullable Integer innerRecordId,
		@Nonnull BigDecimal priceWithoutTax, @Nonnull BigDecimal taxRate, @Nonnull BigDecimal priceWithTax,
		boolean indexed
	) {
		getPricesBuilder().setPrice(
			priceId, priceList, currency, innerRecordId, priceWithoutTax, taxRate, priceWithTax, indexed);
		return this;
	}

	@Override
	public EntityBuilder setPrice(
		int priceId, @Nonnull String priceList, @Nonnull Currency currency, @Nonnull BigDecimal priceWithoutTax,
		@Nonnull BigDecimal taxRate, @Nonnull BigDecimal priceWithTax, DateTimeRange validity, boolean indexed
	) {
		getPricesBuilder().setPrice(
			priceId, priceList, currency, priceWithoutTax, taxRate, priceWithTax, validity, indexed);
		return this;
	}

	@Override
	public EntityBuilder setPrice(
		int priceId, @Nonnull String priceList, @Nonnull Currency currency, @Nullable Integer innerRecordId,
		@Nonnull BigDecimal priceWithoutTax, @Nonnull BigDecimal taxRate, @Nonnull BigDecimal priceWithTax,
		@Nullable DateTimeRange validity, boolean indexed
	) {
		getPricesBuilder().setPrice(
			priceId, priceList, currency, innerRecordId, priceWithoutTax, taxRate, priceWithTax, validity, indexed);
		return this;
	}

	@Override
	public EntityBuilder removePrice(int priceId, @Nonnull String priceList, @Nonnull Currency currency) {
		getPricesBuilder().removePrice(priceId, priceList, currency);
		return this;
	}

	@Override
	public EntityBuilder setPriceInnerRecordHandling(@Nonnull PriceInnerRecordHandling priceInnerRecordHandling) {
		getPricesBuilder().setPriceInnerRecordHandling(priceInnerRecordHandling);
		return this;
	}

	@Override
	public EntityBuilder removePriceInnerRecordHandling() {
		getPricesBuilder().removePriceInnerRecordHandling();
		return this;
	}

	@Override
	public EntityBuilder removeAllNonTouchedPrices() {
		getPricesBuilder().removeAllNonTouchedPrices();
		return this;
	}

	/**
	 * Builds a single {@link EntityMutation} representing an upsert of a brand new entity.
	 *
	 * Behavior specifics:
	 * - Uses {@link EntityExistence#MUST_NOT_EXIST} to enforce initial creation semantics.
	 * - Adds {@link SetEntityScopeMutation} only when the scope differs from LIVE (default is kept implicit).
	 * - Adds {@link SetParentMutation} when a parent was set.
	 * - Emits reference insert and their attribute/group mutations.
	 * - Emits attribute, associated data and price mutations. Price inner record handling is always
	 * set explicitly to guarantee deterministic state.
	 */
	@Nonnull
	@Override
	public Optional<EntityMutation> toMutation() {
		final List<LocalMutation<?, ?>> mutations = new ArrayList<>(16);

		// scope mutation (if not LIVE)
		if (this.scope != Scope.LIVE) {
			mutations.add(new SetEntityScopeMutation(this.scope));
		}

		// parent mutation (if present)
		if (this.parent != null) {
			mutations.add(new SetParentMutation(this.parent));
		}

		// reference mutations
		if (this.referencesBuilder != null) {
			this.referencesBuilder.buildChangeSet().forEach(mutations::add);
		}

		// entity attributes (non-null only)
		if (this.attributesBuilder != null) {
			this.attributesBuilder.buildChangeSet().forEach(mutations::add);
		}

		// associated data
		if (this.associatedDataBuilder != null) {
			this.associatedDataBuilder.buildChangeSet().forEach(mutations::add);
		}

		// prices
		if (this.pricesBuilder != null) {
			this.pricesBuilder.buildChangeSet().forEach(mutations::add);
		}

		return of(
			new EntityUpsertMutation(
				getType(),
				getPrimaryKey(),
				EntityExistence.MUST_NOT_EXIST,
				mutations
			)
		);
	}

	/**
	 * Materializes the builder into an immutable {@link Entity}.
	 *
	 * Notes:
	 * - Uses empty containers when a particular builder was never touched to minimize footprint.
	 * - Combines schema-declared reference names with those added in this builder.
	 * - The hierarchy flag is set when schema declares hierarchy or a parent was assigned.
	 */
	@Nonnull
	@Override
	public Entity toInstance() {
		return Entity._internalBuild(
			this.primaryKey,
			version(),
			this.schema,
			this.parent,
			this.referencesBuilder == null ?
				new References(this.schema) : this.referencesBuilder.build(),
			this.attributesBuilder == null ?
				new EntityAttributes(this.schema) : this.attributesBuilder.build(),
			this.associatedDataBuilder == null ?
				new AssociatedData(this.schema) : this.associatedDataBuilder.build(),
			this.pricesBuilder == null ?
				new Prices(this.schema, PriceInnerRecordHandling.NONE) : this.pricesBuilder.build(),
			getAllLocales(),
			false
		);
	}

	/**
	 * Asserts that the hierarchy operation is allowed based on the current schema configuration.
	 * This check validates that the schema either supports hierarchy explicitly or allows the
	 * addition of hierarchy through its evolution mode settings. If neither condition is met,
	 * an {@link InvalidMutationException} is thrown with a detailed message indicating that
	 * hierarchy operations are not permitted.
	 *
	 * Throws:
	 * - InvalidMutationException: Thrown if the schema does not support hierarchy
	 * and does not allow adding hierarchy in evolution mode.
	 */
	private void assertHierarchyAllowed() {
		Assert.isTrue(
			this.schema.isWithHierarchy() || this.schema.allows(EvolutionMode.ADDING_HIERARCHY),
			() -> new InvalidMutationException(
				"Schema `" + this.schema.getName() + "` is not configured to support hierarchy."
			)
		);
	}

	@Delegate(types = AttributesContract.class)
	@Nonnull
	private InitialEntityAttributesBuilder getAttributesBuilder() {
		if (this.attributesBuilder == null) {
			this.attributesBuilder = new InitialEntityAttributesBuilder(this.schema);
		}
		return this.attributesBuilder;
	}

	@Delegate(types = AssociatedDataContract.class)
	@Nonnull
	private InitialAssociatedDataBuilder getAssociatedDataBuilder() {
		if (this.associatedDataBuilder == null) {
			this.associatedDataBuilder = new InitialAssociatedDataBuilder(this.schema);
		}
		return this.associatedDataBuilder;
	}

	@Delegate(types = PricesContract.class, excludes = Versioned.class)
	@Nonnull
	private InitialPricesBuilder getPricesBuilder() {
		if (this.pricesBuilder == null) {
			this.pricesBuilder = new InitialPricesBuilder(this.schema);
		}
		return this.pricesBuilder;
	}

	@Delegate(types = ReferencesContract.class)
	@Nonnull
	private InitialReferencesBuilder getReferencesBuilder() {
		if (this.referencesBuilder == null) {
			this.referencesBuilder = new InitialReferencesBuilder(this.schema);
		}
		return this.referencesBuilder;
	}

}
